<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Run Arena - Character Selection & Race Game</title>
    <link rel="shortcut icon" href="logo.png" type="image/png">
    <!-- LIBRARIES -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.1/dist/nipplejs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/izitoast/1.4.0/js/iziToast.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/izitoast/1.4.0/css/iziToast.min.css">

    <!-- Import Map for Three.js -->
    <script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/"
    }
}
</script>

    <style>
        /* GLOBAL RESET & BASE */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        /* Allow typing in inputs */
        input,
        textarea {
            user-select: text !important;
            pointer-events: auto !important;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            color: white;
            height: 100vh;
            width: 100vw;
            touch-action: manipulation;
            /* âœ… allows clicks & typing */


            /* Prevent scroll/zoom on mobile */
        }

        /* --- INITIAL LOADER --- */
        #initialLoader {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
            z-index: 9999;
        }

        #loaderSpinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00d4ff;
            border-left-color: #ff3e7f;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 2rem;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
        }

        #loaderText {
            font-size: 24px;
            font-weight: 800;
            letter-spacing: 8px;
            background: linear-gradient(90deg, #00d4ff, #ff3e7f, #ffd700);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* --- SELECTION BACKGROUND PARTICLES --- */
        #selectionParticles {
            position: fixed;
            inset: 0;
            z-index: 1;
            pointer-events: none;
        }

        /* --- CHARACTER SELECTION (GOD LEVEL) --- */
        #characterSelect {
            position: absolute;
            inset: 0;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 4vh;
            background: transparent;
            /* Rely on body/particles */
            opacity: 0;
            visibility: hidden;
            /* Custom scrollbar for overflow */
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #00d4ff #1a0b2e;
        }

        /* Header Section */
        .selection-header {
            text-align: center;
            z-index: 2;
            margin-bottom: 20px;
        }

        #usernameTitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 3px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        #usernameInput {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            border-radius: 30px;
            color: #fff;
            font-size: 1.5rem;
            text-align: center;
            width: 350px;
            outline: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow:
                0 0 10px rgba(0, 212, 255, 0.2),
                inset 0 0 20px rgba(0, 0, 0, 0.5);
            font-family: 'Segoe UI', sans-serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            touch-action: manipulation;
            /* FIX: Allow taps to focus and open keyboard */
        }

        #usernameInput:focus {
            border-color: #00d4ff;
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
            transform: scale(1.05);
        }

        #charTitle {
            font-size: 5rem;
            font-weight: 900;
            text-transform: uppercase;
            margin: 30px 0;
            background: linear-gradient(to right, #fff, #00d4ff, #ff3e7f, #fff);
            background-size: 300% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shineText 4s linear infinite;
            text-shadow: 0 20px 50px rgba(0, 212, 255, 0.3);
            letter-spacing: -2px;
            position: relative;
        }

        @keyframes shineText {
            to {
                background-position: 300% center;
            }
        }

        /* The Grid */
        #charGrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 40px;
            perspective: 2000px;
            /* Deep perspective for 3D effect */
            padding: 20px 80px;
            max-width: 1400px;
            margin-bottom: 50px;
        }

        .charOption {
            position: relative;
            width: 280px;
            height: 400px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            overflow: hidden;
            backdrop-filter: blur(5px);
            transform-style: preserve-3d;
        }

        .charOption::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(0, 212, 255, 0) 0%, rgba(0, 212, 255, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.5s;
        }

        .charOption:hover {
            transform: translateY(-20px) scale(1.05) rotateX(5deg);
            border-color: rgba(0, 212, 255, 0.5);
            box-shadow:
                0 20px 50px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(0, 212, 255, 0.2);
            z-index: 5;
        }

        .charOption:hover::before {
            opacity: 1;
        }

        .charOption.selected {
            border-color: #ffd700;
            box-shadow:
                0 0 50px rgba(255, 215, 0, 0.4),
                inset 0 0 20px rgba(255, 215, 0, 0.2);
            transform: scale(1.1) translateY(-10px);
            z-index: 10;
            background: rgba(255, 215, 0, 0.05);
        }

        /* 3D Model Canvas Area */
        .charCanvas {
            width: 100%;
            height: 85%;
            position: relative;
            z-index: 1;
        }

        .charName {
            height: 15%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 800;
            text-transform: uppercase;
            font-size: 1.2rem;
            letter-spacing: 2px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            z-index: 2;
            transition: all 0.3s;
        }

        .charOption:hover .charName {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
        }

        .charOption.selected .charName {
            background: #ffd700;
            color: #000;
            box-shadow: 0 -10px 30px rgba(255, 215, 0, 0.5);
        }

        /* Continue Button - Racing Style */
        #continueBtn {
            padding: 15px 80px;
            font-size: 1.5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            border: none;
            border-radius: 5px;
            background: linear-gradient(90deg, #ff3e7f, #ffd700);
            color: #000;
            cursor: pointer;
            opacity: 0.5;
            transform: skewX(-20deg);
            transition: all 0.3s ease;
            box-shadow: 10px 10px 0 rgba(0, 0, 0, 0.5);
            margin-bottom: 50px;
            margin-top: 20px;
            pointer-events: none;
            min-width: 300px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #continueBtn span {
            display: block;
            transform: skewX(20deg);
            /* Counter skew text */
        }

        #continueBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
            transition: 0.5s;
        }

        @keyframes gradientMove {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        #continueBtn:not(:disabled) {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
            box-shadow: 0 10px 50px rgba(255, 62, 127, 0.5);
        }

        #continueBtn:not(:disabled) {
            opacity: 1;
            pointer-events: auto;
            transform: skewX(-20deg) scale(1.05);
            box-shadow: 0 0 30px rgba(255, 62, 127, 0.6);
        }

        #continueBtn:not(:disabled):hover {
            transform: skewX(-20deg) scale(1.1);
            background: linear-gradient(90deg, #ffd700, #ff3e7f);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }

        #continueBtn:not(:disabled):hover::before {
            left: 100%;
        }

        /* --- LOBBY LOADER --- */
        #lobbyLoader {
            position: fixed;
            inset: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a0b2e 0%, #000000 100%);
            z-index: 15;
        }

        .running-animation {
            width: 200px;
            height: 200px;
            position: relative;
            margin-bottom: 30px;
        }

        .runner {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #00d4ff, #ff3e7f);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: runBounce 0.6s ease-in-out infinite;
        }

        @keyframes runBounce {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -60%) scale(1.1);
            }
        }

        .motion-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .motion-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, transparent, #00d4ff, transparent);
            animation: slideLeft 1s linear infinite;
        }

        .motion-line:nth-child(1) {
            top: 30%;
            width: 100px;
            animation-delay: 0s;
        }

        .motion-line:nth-child(2) {
            top: 50%;
            width: 120px;
            animation-delay: 0.2s;
        }

        .motion-line:nth-child(3) {
            top: 70%;
            width: 90px;
            animation-delay: 0.4s;
        }

        @keyframes slideLeft {
            from {
                left: 100%;
            }

            to {
                left: -150px;
            }
        }

        #lobbyLoadingText {
            font-size: 28px;
            font-weight: 900;
            letter-spacing: 6px;
            background: linear-gradient(90deg, #00d4ff, #ff3e7f, #ffd700);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* --- RACE FINISH COUNTDOWN --- */
        #raceFinishCountdown {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: none;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
        }

        #countdownLabel {
            font-size: 1.2rem;
            color: #ccc;
            letter-spacing: 5px;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: -10px;
        }

        #countdownValue {
            font-size: 8rem;
            font-weight: 950;
            color: #fff;
            background: linear-gradient(180deg, #fff, #00d4ff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-family: 'Segoe UI', sans-serif;
        }

        /* --- GOD LEVEL BACK BUTTON --- */
        #backToLobbyBtn {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 10001;
            display: none;
            padding: 15px 50px;
            background: linear-gradient(90deg, #00d4ff, #ff3e7f);
            color: #fff;
            border: none;
            border-radius: 5px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transform: skewX(-15deg);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.4);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: buttonPulse 2s infinite;
        }

        #backToLobbyBtn:hover {
            transform: skewX(-15deg) scale(1.1);
            box-shadow: 0 0 60px rgba(255, 62, 127, 0.6);
            letter-spacing: 5px;
        }

        #backToLobbyBtn span {
            display: block;
            transform: skewX(15deg);
        }

        @keyframes buttonPulse {
            0% {
                box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
            }

            50% {
                box-shadow: 0 0 50px rgba(255, 62, 127, 0.7);
            }

            100% {
                box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
            }
        }

        /* --- LOBBY STADIUM --- */
        #lobby {
            position: absolute;
            inset: 0;
            visibility: hidden;
            opacity: 0;
            display: flex;
            /* For flex layout when active */
            flex-direction: column;
            z-index: 20;
        }

        #stadiumCanvas {
            position: absolute;
            inset: 0;
            z-index: 0;
        }

        /* Lobby UI Overlays */
        .lobby-overlay {
            position: relative;
            z-index: 10;
            pointer-events: none;
            /* Let clicks pass through to canvas unless on button */
        }

        #topBar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 40px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
            pointer-events: auto;
        }

        .top-left-group {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .top-right-group {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        /* --- PREMIUM PROFILE PILL (Top Left) --- */
        #profilePill {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 212, 255, 0.5);
            padding: 5px 20px 5px 5px;
            border-radius: 40px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 0 10px rgba(0, 212, 255, 0.1);
            pointer-events: auto;
        }

        #profilePill:hover {
            transform: scale(1.05) translateX(5px);
            border-color: #00d4ff;
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
            background: rgba(0, 40, 60, 0.7);
        }

        #coinPill {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ffd700;
            padding: 5px 15px;
            border-radius: 20px;
            margin-left: 15px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
            backdrop-filter: blur(10px);
            animation: coinPulse 2s infinite ease-in-out;
        }

        @keyframes coinPulse {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
            }

            50% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            }
        }

        .coin-icon {
            font-size: 1.2rem;
            margin-right: 8px;
            filter: drop-shadow(0 0 5px #ffd700);
        }

        #coinBalanceTop {
            font-weight: 900;
            color: #ffd700;
            font-size: 1rem;
            letter-spacing: 1px;
        }

        .pill-avatar {
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, #00d4ff, #ff3e7f);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            margin-right: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .pill-info {
            display: flex;
            flex-direction: column;
        }

        .pill-name {
            font-weight: 900;
            font-size: 0.9rem;
            letter-spacing: 1px;
            color: #fff;
            text-transform: uppercase;
        }

        .pill-level {
            font-size: 0.7rem;
            color: #ffd700;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .lvl-bar {
            width: 60px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 2px;
        }

        .lvl-progress {
            width: 65%;
            height: 100%;
            background: #ffd700;
            box-shadow: 0 0 5px #ffd700;
        }

        /* --- PROFILE MODAL (FF STYLE) --- */
        #profileModal {
            position: fixed;
            inset: 0;
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        #profileModal.active {
            display: flex;
            opacity: 1;
        }

        .profile-container {
            width: 90vw;
            height: 80vh;
            max-width: 1100px;
            background: linear-gradient(135deg, #0a0a1a 0%, #16162d 100%);
            border: 1px solid rgba(0, 212, 255, 0.3);
            position: relative;
            display: flex;
            overflow: hidden;
            border-radius: 5px;
            box-shadow: 0 0 100px rgba(0, 0, 0, 1);
            transform: scale(0.9);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #profileModal.active .profile-container {
            transform: scale(1);
        }

        /* Decorative Corners */
        .corner {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 2px solid #00d4ff;
            pointer-events: none;
        }

        .corner-tl {
            top: -2px;
            left: -2px;
            border-right: none;
            border-bottom: none;
        }

        .corner-tr {
            top: -2px;
            right: -2px;
            border-left: none;
            border-bottom: none;
        }

        .corner-bl {
            bottom: -2px;
            left: -2px;
            border-right: none;
            border-top: none;
        }

        .corner-br {
            bottom: -2px;
            right: -2px;
            border-left: none;
            border-top: none;
        }

        .profile-sidebar {
            width: 250px;
            background: rgba(0, 0, 0, 0.3);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            padding: 40px 0;
        }

        .side-tab {
            padding: 20px 40px;
            color: #888;
            font-weight: 800;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid transparent;
            text-transform: uppercase;
            font-size: 0.9rem;
        }

        .side-tab:hover,
        .side-tab.active {
            color: #fff;
            background: linear-gradient(90deg, rgba(0, 212, 255, 0.1), transparent);
            border-left-color: #00d4ff;
        }

        .profile-main {
            flex: 1;
            padding: 40px;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 2;
        }

        .profile-header-info {
            margin-bottom: 40px;
        }

        .prof-name {
            font-size: 3rem;
            font-weight: 900;
            color: #fff;
            text-transform: uppercase;
            margin: 0;
            line-height: 1;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .prof-uid {
            color: #00d4ff;
            font-size: 0.8rem;
            letter-spacing: 3px;
            margin-top: 5px;
            opacity: 0.7;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 40px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .stat-card:hover {
            background: rgba(0, 212, 255, 0.05);
            border-color: rgba(0, 212, 255, 0.2);
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 900;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 5px;
        }

        /* Rank Section */
        .rank-display {
            margin-top: 50px;
            display: flex;
            align-items: center;
            gap: 30px;
            background: rgba(0, 0, 0, 0.4);
            padding: 30px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .rank-icon {
            width: 90px;
            height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rank-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.5));
        }

        .rank-info h3 {
            color: #ffd700;
            font-size: 1.5rem;
            margin: 0;
            text-transform: uppercase;
        }

        .rank-info p {
            color: #888;
            margin: 5px 0 0 0;
            font-size: 0.9rem;
        }

        /* 3D View */
        .profile-3d-view {
            width: 450px;
            background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.4));
            position: relative;
            border-left: 1px solid rgba(255, 255, 255, 0.05);
        }

        #profileCharCanvas {
            width: 100%;
            height: 100%;
        }

        .close-profile {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 62, 127, 0.2);
            border: 1px solid #ff3e7f;
            color: #ff3e7f;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s;
        }

        .close-profile:hover {
            background: #ff3e7f;
            color: #fff;
            transform: rotate(90deg);
        }

        .prof-badge {
            display: inline-block;
            background: #ffd700;
            color: #000;
            padding: 3px 10px;
            border-radius: 4px;
            font-weight: 900;
            font-size: 0.7rem;
            margin-left: 15px;
            vertical-align: middle;
        }

        #bottomBar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            pointer-events: auto;
        }

        /* Buttons */
        .game-btn {
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-weight: 800;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            pointer-events: auto;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ff3e7f 0%, #ff6b35 100%);
            color: white;
            box-shadow: 0 10px 30px rgba(255, 62, 127, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 62, 127, 0.6);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
        }

        .btn-secondary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: rgba(100, 100, 100, 0.2);
        }

        .btn-secondary:disabled:hover {
            transform: none;
            background: rgba(100, 100, 100, 0.2);
        }

        .btn-ready {
            background: rgba(0, 255, 100, 0.1) !important;
            border-color: rgba(0, 255, 100, 0.3) !important;
            color: #0f6 !important;
        }

        .btn-ready.active {
            background: #0f6 !important;
            color: #000 !important;
            box-shadow: 0 0 20px rgba(0, 255, 100, 0.5);
        }

        /* PANELS */
        .floating-panel {
            position: absolute;
            background: rgba(16, 16, 32, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            pointer-events: auto;
            opacity: 0;
            visibility: hidden;
            z-index: 100;
        }

        #emotePanel {
            bottom: 110px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 400px;
            border: 1px solid #00d4ff;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        .emote-btn {
            background: rgba(255, 255, 255, 0.05);
            border: none;
            padding: 15px 10px;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: 0.2s;
        }

        .emote-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: scale(1.05);
        }

        /* --- GOD LEVEL UI: SHOP & PROFILE --- */

        /* Common Modal Backdrop */
        #shopModal,
        #profileModal {
            position: fixed;
            inset: 0;
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(5, 5, 10, 0.85);
            /* Darker, richer backdrop */
            backdrop-filter: blur(20px);
            /* Heavy blur for premium feel */
            opacity: 0;
            transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #shopModal.active,
        #profileModal.active {
            display: flex;
            opacity: 1;
        }

        /* --- SHOP STYLES --- */
        .shop-container {
            width: 90vw;
            height: 85vh;
            max-width: 1400px;
            background: linear-gradient(145deg, rgba(20, 20, 35, 0.6) 0%, rgba(10, 10, 20, 0.8) 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            display: flex;
            overflow: hidden;
            border-radius: 24px;
            box-shadow:
                0 0 0 1px rgba(0, 212, 255, 0.1),
                /* Subtle inner border */
                0 20px 80px rgba(0, 0, 0, 0.8),
                /* Deep shadow */
                0 0 100px rgba(0, 212, 255, 0.1);
            /* Ambient glow */
            transform: scale(0.95);
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #shopModal.active .shop-container {
            transform: scale(1);
        }

        .shop-left {
            width: 35%;
            /* Slightly narrower for more content space */
            position: relative;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            background: radial-gradient(circle at 50% 50%, rgba(0, 212, 255, 0.05) 0%, transparent 70%);
        }

        #shopCharCanvas {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.5));
        }

        .shop-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 40px;
            background: rgba(0, 0, 0, 0.2);
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .shop-title {
            font-size: 3rem;
            font-weight: 900;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 6px;
            margin: 0;
            /* Gradient Text */
            background: linear-gradient(to right, #fff, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            drop-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
        }

        .shop-balance {
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 12px 30px;
            border-radius: 12px;
            color: #ffd700;
            font-weight: 800;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.15);
        }

        .shop-tabs {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding-bottom: 5px;
        }

        .shop-tab {
            padding: 12px 20px;
            background: transparent;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            letter-spacing: 2px;
            font-size: 0.9rem;
        }

        .shop-tab::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            width: 0%;
            height: 3px;
            background: #00d4ff;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #00d4ff;
        }

        .shop-tab:hover {
            color: #fff;
        }

        .shop-tab.active {
            color: #fff;
        }

        .shop-tab.active::after {
            width: 100%;
        }

        .shop-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 25px;
            overflow-y: auto;
            padding: 10px;
            /* Hiding scrollbar visually but keeping function */
            scrollbar-width: thin;
        }

        .shop-item {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            cursor: pointer;
            overflow: hidden;
        }

        .shop-item:hover {
            background: rgba(255, 255, 255, 0.08);
            /* Lighter on hover */
            border-color: rgba(0, 212, 255, 0.5);
            transform: translateY(-8px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
        }

        .shop-item:hover .item-icon {
            transform: scale(1.1) rotate(5deg);
        }

        .shop-item.equipped {
            border-color: #0f6;
            background: rgba(0, 255, 100, 0.05);
        }

        .item-icon {
            width: 120px;
            height: 120px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            /* Nice radial glow behind item */
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            border-radius: 50%;
            transition: transform 0.4s ease;
        }

        .item-name {
            font-weight: 800;
            font-size: 1rem;
            color: #fff;
            text-transform: uppercase;
            text-align: center;
            margin-bottom: 15px;
            letter-spacing: 1px;
        }

        .item-price {
            margin-top: auto;
            color: #ffd700;
            font-weight: 900;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn-buy {
            width: 100%;
            margin-top: 15px;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 900;
            text-transform: uppercase;
            cursor: pointer;
            transition: 0.3s;
            background: linear-gradient(90deg, #ff3e7f, #ff6b35);
            /* Hot gradient */
            color: #fff;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn-buy::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: 0.5s;
        }

        .btn-buy:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 62, 127, 0.4);
        }

        .btn-buy:hover::before {
            left: 100%;
        }

        .btn-equip {
            background: linear-gradient(90deg, #00d4ff, #0080ff);
            /* Cool gradient */
        }

        .btn-equip:hover {
            box-shadow: 0 10px 20px rgba(0, 212, 255, 0.4);
        }

        .close-shop,
        .close-profile {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s;
            font-size: 1.8rem;
            backdrop-filter: blur(5px);
        }

        .close-shop:hover,
        .close-profile:hover {
            background: rgba(255, 62, 127, 0.8);
            border-color: transparent;
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 0 20px rgba(255, 62, 127, 0.6);
        }


        /* --- PROFILE STYLES (PREMIUM) --- */

        .profile-container {
            width: 85vw;
            height: 80vh;
            max-width: 1200px;
            display: flex;
            position: relative;
            z-index: 10;
        }

        /* Glass Panel behind content */
        .profile-container::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(15, 15, 25, 0.85);
            /* Deep dark blue-grey */
            backdrop-filter: blur(30px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 30px 100px rgba(0, 0, 0, 0.8);
            z-index: -1;
        }

        /* Decorative Corners */
        .corner {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 2px solid #00d4ff;
            opacity: 0.6;
            transition: all 0.3s;
        }

        .corner-tl {
            top: -2px;
            left: -2px;
            border-right: none;
            border-bottom: none;
            border-radius: 10px 0 0 0;
        }

        .corner-tr {
            top: -2px;
            right: -2px;
            border-left: none;
            border-bottom: none;
            border-radius: 0 10px 0 0;
        }

        .corner-bl {
            bottom: -2px;
            left: -2px;
            border-right: none;
            border-top: none;
            border-radius: 0 0 0 10px;
        }

        .corner-br {
            bottom: -2px;
            right: -2px;
            border-left: none;
            border-top: none;
            border-radius: 0 0 10px 0;
        }

        .profile-container:hover .corner {
            width: 40px;
            height: 40px;
            opacity: 1;
            box-shadow: 0 0 15px #00d4ff;
        }

        .profile-sidebar {
            width: 280px;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            padding: 40px 0;
        }

        .side-tab {
            padding: 18px 40px;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 800;
            font-size: 1.1rem;
            cursor: pointer;
            transition: 0.3s;
            position: relative;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .side-tab:hover {
            color: #fff;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.02), transparent);
            padding-left: 50px;
            /* Slight slide */
        }

        .side-tab.active {
            color: #00d4ff;
            background: linear-gradient(90deg, rgba(0, 212, 255, 0.1), transparent);
            border-left: 4px solid #00d4ff;
        }

        .profile-main {
            flex: 1;
            padding: 50px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .profile-header-info {
            margin-bottom: 40px;
            animation: slideDown 0.6s ease-out;
        }

        .prof-name {
            font-size: 3.5rem;
            font-weight: 900;
            margin: 0;
            color: #fff;
            letter-spacing: 2px;
            text-transform: uppercase;
            line-height: 1;
            /* Text Shader */
            background: linear-gradient(135deg, #fff 40%, #888 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .prof-badge {
            font-size: 0.9rem;
            background: #ffd700;
            color: #000 !important;
            /* Force black text */
            padding: 4px 12px;
            border-radius: 4px;
            vertical-align: middle;
            margin-left: 15px;
            font-weight: 800;
            /* Extra bold */
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            display: inline-block;
            /* Ensure it takes box shape */
            text-shadow: none;
            /* Remove any text shadows that might hide distinctness */
        }

        .prof-uid {
            font-family: 'Courier New', monospace;
            color: rgba(0, 212, 255, 0.6);
            font-size: 1rem;
            margin-top: 10px;
            letter-spacing: 1px;
        }

        /* Constrain text content so it doesn't go under the character */
        .profile-details {
            display: flex;
            flex-direction: column;
            width: 100%;
            padding-right: 300px;
            /* Add massive padding to right to clear the character */
        }

        /* 3D View Overlap Fix */
        .profile-3d-view {
            position: absolute;
            right: -50px;
            /* Move closer to edge, but not off-screen */
            top: 0;
            height: 100%;
            width: 500px;
            /* Output fixed width */
            z-index: 5;
            pointer-events: none;
            filter: drop-shadow(-20px 0 30px rgba(0, 0, 0, 0.8));
            animation: fadeInRight 1s ease-out;
            mask-image: linear-gradient(to right, transparent, black 15%);
            -webkit-mask-image: linear-gradient(to right, transparent, black 15%);
        }

        @keyframes fadeInRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Stats Grid */
        .stats-grid {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            flex: 1;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 25px;
            border-radius: 16px;
            text-align: center;
            transition: 0.3s;
            position: relative;
            overflow: hidden;
        }

        .stat-card:hover {
            background: rgba(255, 255, 255, 0.06);
            transform: translateY(-5px);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .stat-value {
            display: block;
            font-size: 2.5rem;
            font-weight: 900;
            color: #fff;
            margin-bottom: 5px;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            font-weight: 700;
            letter-spacing: 2px;
        }

        /* Rank Section */
        .rank-display {
            display: flex;
            align-items: center;
            margin-top: 40px;
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.05), transparent);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #ffd700;
        }

        .rank-icon {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            margin-right: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.1);
        }

        .rank-icon img {
            width: 60%;
            height: auto;
        }

        .rank-info h3 {
            margin: 0;
            font-size: 1.5rem;
            color: #ffd700;
            text-transform: uppercase;
        }

        .rank-info p {
            margin: 5px 0 0 0;
            color: #ccc;
            font-size: 0.9rem;
        }

        #profileCharCanvas {
            width: 100%;
            height: 100%;
        }

        /* --- GAME UI --- */
        #gameLoader {
            position: absolute;
            inset: 0;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 50;
        }

        #gameUI {
            position: absolute;
            inset: 0;
            display: none;
            z-index: 50;
            pointer-events: none;
            /* Let clicks pass through */
            touch-action: none;
            /* Disable browser gestures */
        }

        #stadiumCanvas {
            pointer-events: auto;
            /* Ensure canvas catches events if needed */
        }



        #gameUI>* {
            pointer-events: auto;
            /* Re-enable for buttons/joystick */
        }

        /* Custom Scrollbar for list */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 4px;
        }

        /* Responsiveness */
        @media (max-width: 1200px) {
            #charGrid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            #charGrid {
                grid-template-columns: 1fr;
            }

            #charTitle {
                font-size: 3rem;
            }
        }

        /* --- FRIEND SYSTEM & INVITES --- */
        #friendPanel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 400px;
            height: 100vh;
            background: linear-gradient(to left, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.98));
            backdrop-filter: blur(20px);
            border-left: 2px solid #ffd700;
            z-index: 200;
            transition: right 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            display: flex;
            flex-direction: column;
            box-shadow: -20px 0 50px rgba(0, 0, 0, 0.8);
        }

        #friendPanel.active {
            right: 0;
        }

        .panel-header {
            padding: 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 215, 0, 0.05);
            /* Gold tint */
        }

        .panel-header h2 {
            font-size: 1.5rem;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            transition: 0.2s;
            line-height: 1;
        }

        .close-btn:hover {
            color: #ff3e7f;
            transform: rotate(90deg);
        }

        .friend-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            padding: 0 10px;
        }

        .f-tab {
            flex: 1;
            padding: 20px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: 0.3s;
            border-bottom: 3px solid transparent;
            letter-spacing: 1px;
        }

        .f-tab.active {
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
            border-bottom-color: #00d4ff;
        }

        .friend-list {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .friend-item {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 12px 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            transition: 0.2s;
            position: relative;
            overflow: hidden;
        }

        .friend-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #555;
            transition: 0.2s;
        }

        .friend-item.online::before {
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
        }

        .friend-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(-5px);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .f-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(135deg, #111, #333);
            margin-right: 15px;
            border: 2px solid #555;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #888;
        }

        .friend-item.online .f-avatar {
            border-color: #0f0;
            color: #0f0;
        }

        .f-info {
            flex: 1;
        }

        .f-name {
            font-weight: bold;
            font-size: 1.1rem;
            color: #fff;
            display: block;
        }

        .f-status {
            font-size: 0.8rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .friend-item.online .f-status {
            color: #0f0;
        }

        .f-actions {
            display: flex;
            gap: 5px;
        }

        .f-btn {
            width: 35px;
            height: 35px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
            font-size: 1.2rem;
        }

        .btn-invite {
            background: rgba(0, 212, 255, 0.1);
            color: #00d4ff;
        }

        .btn-invite:hover {
            background: #00d4ff;
            color: #000;
            box-shadow: 0 0 15px #00d4ff;
            transform: scale(1.1);
        }

        .btn-remove {
            background: rgba(255, 62, 127, 0.1);
            color: #ff3e7f;
            display: none;
        }

        /* Show on hover maybe? */
        .friend-item:hover .btn-remove {
            display: flex;
        }

        .btn-remove:hover {
            background: #ff3e7f;
            color: #fff;
        }

        .panel-footer {
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .add-friend-box {
            display: flex;
            gap: 10px;
        }

        .add-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 15px;
            border-radius: 5px;
            color: #fff;
            outline: none;
            font-family: inherit;
        }

        .add-input:focus {
            border-color: #ffd700;
            background: rgba(255, 255, 255, 0.15);
        }

        .add-btn-submit {
            background: #ffd700;
            color: #000;
            border: none;
            padding: 0 20px;
            border-radius: 5px;
            font-weight: 900;
            cursor: pointer;
            text-transform: uppercase;
        }

        .add-btn-submit:hover {
            background: #fff;
            box-shadow: 0 0 15px #ffd700;
        }

        /* --- PREMIUM SEARCH BAR (ADD TAB) --- */
        #searchContainer {
            padding: 25px;
            display: none;
            flex-direction: column;
            height: 100%;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.2) 100%);
        }

        .search-wrapper {
            position: relative;
            margin-bottom: 30px;
            z-index: 5;
        }

        .search-input {
            width: 100%;
            padding: 18px 50px 18px 25px;
            background: rgba(15, 15, 25, 0.8);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 16px;
            color: #fff;
            font-size: 1.1rem;
            outline: none;
            backdrop-filter: blur(12px);
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow:
                inset 0 2px 10px rgba(0, 0, 0, 0.5),
                0 10px 20px rgba(0, 0, 0, 0.2);
            font-family: 'Segoe UI', sans-serif;
            letter-spacing: 0.5px;
        }

        .search-input:focus {
            background: rgba(10, 10, 20, 0.95);
            border-color: #00d4ff;
            box-shadow:
                0 0 30px rgba(0, 212, 255, 0.25),
                inset 0 0 20px rgba(0, 212, 255, 0.05);
            transform: scale(1.02);
        }

        .search-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(0, 212, 255, 0.6);
            font-size: 1.4rem;
            pointer-events: none;
            transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .search-input:focus+.search-icon {
            color: #fff;
            transform: translateY(-50%) scale(1.2) rotate(10deg);
            text-shadow: 0 0 15px #00d4ff;
        }

        #searchResults {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 5px;
            /* Padding for hover overflow */
        }

        .result-item {
            display: flex;
            align-items: center;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%);
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            opacity: 0;
            animation: slideInResult 0.5s ease-out forwards;
        }

        @keyframes slideInResult {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .result-item:nth-child(1) {
            animation-delay: 0.05s;
        }

        .result-item:nth-child(2) {
            animation-delay: 0.1s;
        }

        .result-item:nth-child(3) {
            animation-delay: 0.15s;
        }

        .result-item:nth-child(4) {
            animation-delay: 0.2s;
        }

        .result-item:nth-child(5) {
            animation-delay: 0.25s;
        }

        .result-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: #00d4ff;
            opacity: 0;
            transition: 0.3s;
            box-shadow: 0 0 10px #00d4ff;
        }

        .result-item:hover {
            background: rgba(255, 255, 255, 0.07);
            transform: translateX(5px) translateY(-5px);
            border-color: rgba(0, 212, 255, 0.3);
            box-shadow:
                -5px 10px 20px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 212, 255, 0.1);
            z-index: 2;
        }

        .result-item:hover::before {
            opacity: 1;
        }

        .r-name {
            flex: 1;
            font-weight: 700;
            margin-left: 15px;
            font-size: 1.15rem;
            color: #ccc;
            transition: 0.3s;
            letter-spacing: 0.5px;
        }

        .result-item:hover .r-name {
            color: #fff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.6);
        }

        .result-item .f-avatar {
            /* Using existing f-avatar base but enhancing */
            width: 48px;
            height: 48px;
            font-size: 1.4rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: 0.4s;
        }

        .result-item:hover .f-avatar {
            border-color: #ffd700;
            transform: rotate(-10deg) scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            color: #ffd700;
        }

        .btn-add {
            background: rgba(0, 212, 255, 0.1);
            color: #00d4ff;
            border: 1px solid rgba(0, 212, 255, 0.3);
            width: 42px;
            height: 42px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            overflow: hidden;
            position: relative;
        }

        .btn-add::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transform: translateX(-100%);
            transition: 0.4s;
        }

        .btn-add:hover {
            background: #00d4ff;
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.6);
            border-color: transparent;
        }

        .btn-add:hover::after {
            transform: translateX(100%);
        }

        /* INVITE POPUP */
        #invitePopup {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translate(-50%, -150%);
            width: 500px;
            background: linear-gradient(135deg, rgba(20, 20, 30, 0.98) 0%, rgba(10, 10, 20, 0.98) 100%);
            border: 1px solid #ffd700;
            border-radius: 6px;
            z-index: 1000;
            display: flex;
            overflow: hidden;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8), 0 0 30px rgba(255, 215, 0, 0.2);
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            opacity: 0;
            visibility: hidden;
        }

        #invitePopup.active {
            transform: translate(-50%, 0);
            opacity: 1;
            visibility: visible;
        }

        .inv-left {
            width: 120px;
            background: rgba(255, 215, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            border-right: 1px solid rgba(255, 215, 0, 0.2);
            padding: 20px 0;
        }

        .inv-avatar {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #333;
            border: 3px solid #fff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        .inv-right {
            flex: 1;
            padding: 25px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .inv-title {
            color: #ffd700;
            font-size: 0.9rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .inv-msg {
            font-size: 1.3rem;
            color: #fff;
            margin-bottom: 25px;
            font-weight: 300;
            line-height: 1.3;
        }

        .inv-msg strong {
            font-weight: 800;
            color: #00d4ff;
        }

        .inv-actions {
            display: flex;
            gap: 15px;
        }

        .inv-btn {
            flex: 1;
            padding: 12px;
            border: none;
            font-weight: 800;
            text-transform: uppercase;
            cursor: pointer;
            letter-spacing: 1px;
            clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
            transition: 0.2s;
        }

        .inv-accept {
            background: linear-gradient(90deg, #ffd700, #ffb700);
            color: #000;
        }

        .inv-accept:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .inv-decline {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .inv-decline:hover {
            background: rgba(255, 62, 127, 0.2);
            color: #ff3e7f;
            border-color: #ff3e7f;
        }

        /* SQUAD LIST (Left side) */
        #squadList {
            position: absolute;
            left: 30px;
            top: 20%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
            pointer-events: none;
        }

        .squad-card {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 10px 15px;
            border-radius: 0 30px 30px 0;
            border-left: 4px solid #00d4ff;
            width: 250px;
            transform: translateX(-300px);
            /* Hidden initially */
            animation: slideInSquad 0.5s forwards;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.5);
        }

        @keyframes slideInSquad {
            to {
                transform: translateX(0);
            }
        }

        .sq-avatar {
            width: 40px;
            height: 40px;
            background: #333;
            border-radius: 50%;
            margin-right: 15px;
            border: 2px solid #fff;
        }

        .sq-name {
            font-weight: bold;
            color: #fff;
        }

        .sq-status {
            font-size: 0.8rem;
            color: #00d4ff;
        }

        #friendPanel,
        #friendPanel * {
            pointer-events: auto !important;
        }

        #friendPanel,
        #friendPanel * {
            pointer-events: auto !important;
            user-select: text !important;
            touch-action: manipulation !important;
        }

        #friendPanel input {
            z-index: 1000;
        }

        #searchContainer {
            /* Reset to default flex behavior inside panel */
            position: relative !important;
            top: auto;
            left: auto;
            right: auto;
            z-index: 1001 !important;
            pointer-events: auto !important;
            width: 100%;
        }

        #playerSearchInput {
            pointer-events: auto !important;
            user-select: text !important;
            touch-action: manipulation !important;
            background: rgba(0, 0, 0, 0.8);
        }

        /* User Request: Move victory toast up above the button */
        .victory-toast {
            margin-bottom: 80px !important;
        }

        /* Constrain text content - Reset padding since char is gone */
        .profile-details {
            display: flex;
            flex-direction: column;
            width: 100%;
            padding-right: 0;
        }

        :root {
            --primary: #00d4ff;
            --secondary: #ff3e7f;
            --accent: #ffd700;
            --bg-dark: #0a0a1a;
            --bg-darker: #000000;
            --glass: rgba(15, 15, 30, 0.6);
            --glass-border: rgba(255, 255, 255, 0.08);
            --text: #ffffff;
            --text-dim: #aaaaaa;
            --shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            --glow-primary: 0 0 30px rgba(0, 212, 255, 0.4);
            --glow-secondary: 0 0 30px rgba(255, 62, 127, 0.4);
            --glow-accent: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        input,
        textarea,
        button {
            user-select: text !important;
            pointer-events: auto !important;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-darker);
            font-family: 'Rajdhani', sans-serif;
            color: var(--text);
            height: 100vh;
            width: 100vw;
            touch-action: manipulation;
        }

        /* === LOADER === */
        #initialLoader {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
            z-index: 9999;
        }

        #loaderSpinner {
            width: 100px;
            height: 100px;
            border: 6px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--primary);
            border-left-color: var(--secondary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: var(--glow-primary);
        }

        #loaderText {
            font-size: 2.5rem;
            font-weight: 900;
            letter-spacing: 10px;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-top: 2rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* === CHARACTER SELECTION === */
        #characterSelect {
            position: absolute;
            inset: 0;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 5vh;
            opacity: 0;
            visibility: hidden;
        }

        #charTitle {
            font-size: 6rem;
            font-weight: 900;
            letter-spacing: 8px;
            background: linear-gradient(to right, #fff, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shineText 5s linear infinite;
            text-shadow: var(--glow-primary);
        }

        @keyframes shineText {
            to {
                background-position: 300% center;
            }
        }

        #charGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 40px;
            padding: 40px;
            max-width: 1600px;
        }

        .charOption {
            position: relative;
            width: 300px;
            height: 450px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.5s ease;
            box-shadow: var(--shadow);
        }

        .charOption:hover {
            transform: translateY(-20px) scale(1.08);
            border-color: var(--primary);
            box-shadow: 0 30px 80px rgba(0, 212, 255, 0.4);
        }

        .charOption.selected {
            border-color: var(--accent);
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.5);
            transform: scale(1.1);
        }

        .charCanvas {
            width: 100%;
            height: 85%;
        }

        .charName {
            height: 15%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6rem;
            font-weight: 900;
            letter-spacing: 3px;
            background: rgba(0, 0, 0, 0.7);
            text-transform: uppercase;
        }

        .charOption.selected .charName {
            background: var(--accent);
            color: #000;
        }

        /* === CONTINUE BUTTON === */
        #continueBtn {
            padding: 18px 100px;
            font-size: 2rem;
            font-weight: 900;
            letter-spacing: 4px;
            background: linear-gradient(135deg, var(--secondary), var(--accent));
            color: #000;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: var(--glow-secondary);
            transition: all 0.4s ease;
            margin: 40px 0;
        }

        #continueBtn:not(:disabled):hover {
            transform: scale(1.1);
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.6);
        }

        /* === LOBBY & MODALS === */
        .modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            z-index: 2000;
        }

        .modal.active {
            display: flex;
        }

        .modal-container {
            width: 90vw;
            max-width: 1300px;
            height: 85vh;
            background: linear-gradient(145deg, var(--bg-dark), var(--bg-darker));
            border-radius: 24px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow), var(--glow-primary);
            overflow: hidden;
            position: relative;
        }

        /* 3D View REMOVED by user request */
        /* .profile-3d-view { display: none; } */
    </style>
</head>

<body>
    <!-- SMART REDIRECT & CORS CHECK -->
    <script>
        (function () {
            if (window.location.protocol === 'file:') {
                console.log('Detected file protocol. Checking for local server at http://localhost:3000...');

                // Try to reach the server
                fetch('http://localhost:3000/index.html', { mode: 'no-cors' })
                    .then(() => {
                        console.log('Local server found! Redirecting to avoid CORS issues...');
                        window.location.href = 'http://localhost:3000/index.html';
                    })
                    .catch(() => {
                        console.error('Local server not found.');
                        // Server not running, show help overlay
                        document.addEventListener('DOMContentLoaded', () => {
                            const overlay = document.createElement('div');
                            overlay.id = 'corsWarningOverlay';
                            overlay.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:radial-gradient(circle at center, #1a0b2e 0%, #000 100%); z-index:999999; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:sans-serif; text-align:center; padding: 40px;';
                            overlay.innerHTML = `
                                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; animation: fadeIn 0.8s ease-out;">
                                    <h1 style="color:#ff3e7f; font-size: 3rem; margin-bottom: 20px; font-weight: 900; letter-spacing: 2px;">ðŸš¨ LOCAL SERVER REQUIRED</h1>
                                    <p style="font-size: 1.3rem; max-width: 700px; line-height: 1.6; color: #ccc;">Modern browsers block 3D assets when the game is opened directly from Explorer (CORS policy).</p>
                                    
                                    <div style="margin: 40px 0; padding: 30px; background: rgba(0, 212, 255, 0.1); border-radius: 20px; border: 2px solid #00d4ff; box-shadow: 0 0 30px rgba(0, 212, 255, 0.2); max-width: 500px;">
                                        <p style="margin: 0; font-weight: 900; color: #00d4ff; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 1px;">TO FIX THIS:</p>
                                        <p style="margin: 15px 0 0 0; font-size: 1.2rem; color: #fff;">Double-click <strong style="color: #ffd700; text-decoration: underline;">Launcher.bat</strong> in the project folder.</p>
                                    </div>
                                    
                                    <p style="color: #666; font-size: 1rem; margin-top: 20px;">This will start the Node.js server and load the game properly automatically.</p>
                                </div>
                                <style>
                                    @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
                                </style>
                            `;
                            document.body.prepend(overlay);
                        });
                    });
            }
        })();
    </script>


    <!-- INITIAL LOADER -->
    <div id="initialLoader">
        <div class="running-animation">
            <div class="runner"></div>
            <div class="motion-lines">
                <div class="motion-line"></div>
                <div class="motion-line"></div>
                <div class="motion-line"></div>
            </div>
        </div>
        <div id="loaderText" style="margin-top:20px;">LOADING ARENA</div>
    </div>

    <!-- BACKGROUND SYSTEM -->
    <canvas id="selectionParticles"></canvas>

    <!-- CHARACTER SELECTION INTERFACE -->
    <div id="characterSelect">
        <div class="selection-header">
            <h2 id="usernameTitle">ENTER IDENTITY</h2>
            <input type="text" id="usernameInput" placeholder="PLAYER ONE" maxlength="12" autocomplete="off">
            <h1 id="charTitle">CHOOSE CHAMPION</h1>
        </div>

        <div id="charGrid">
            <!-- Cards will be populated or are static -->
            <div class="charOption" data-model="assets/character1.glb">
                <canvas class="charCanvas"></canvas>
                <div class="charName">RED RACER</div>
            </div>
            <div class="charOption" data-model="assets/character2.glb">
                <canvas class="charCanvas"></canvas>
                <div class="charName">BLUE BLITZ</div>
            </div>
            <div class="charOption" data-model="assets/character3.glb">
                <canvas class="charCanvas"></canvas>
                <div class="charName">GREEN FLASH</div>
            </div>
            <div class="charOption" data-model="assets/character4.glb">
                <canvas class="charCanvas"></canvas>
                <div class="charName">WHITE STRIKE</div>
            </div>
            <div class="charOption" data-model="assets/character5.glb">
                <canvas class="charCanvas"></canvas>
                <div class="charName">PINK FURY</div>
            </div>
            <div class="charOption" data-model="assets/character6.glb">
                <canvas class="charCanvas"></canvas>
                <div class="charName">YELLOW BOLT</div>
            </div>
        </div>

        <button id="continueBtn" disabled><span>ENTER ARENA</span></button>
    </div>

    <!-- RACE FINISH COUNTDOWN -->
    <div id="raceFinishCountdown">
        <span id="countdownLabel">Returning to Lobby</span>
        <span id="countdownValue">10</span>
    </div>

    <button id="backToLobbyBtn"><span>BACK TO LOBBY</span></button>

    <!-- LOBBY LOADER -->
    <div id="lobbyLoader">
        <div class="running-animation">
            <div class="runner"></div>
            <div class="motion-lines">
                <div class="motion-line"></div>
                <div class="motion-line"></div>
                <div class="motion-line"></div>
            </div>
        </div>
        <div id="lobbyLoadingText">Running to Arena...</div>
    </div>

    <!-- LOBBY INTERFACE -->
    <div id="lobby">
        <div id="topBar" class="lobby-overlay">
            <div class="top-left-group">
                <div id="profilePill">
                    <div class="pill-avatar" id="pillAvatar">ðŸ‘¤</div>
                    <div class="pill-info">
                        <span class="pill-name" id="pillName">PLAYER</span>
                        <div class="pill-level">
                            <span>LVL 12</span>
                            <div class="lvl-bar">
                                <div class="lvl-progress"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="coinPill">
                    <span class="coin-icon">ðŸ’°</span>
                    <span id="coinBalanceTop">0</span>
                </div>
            </div>

            <div class="top-right-group">
                <button class="game-btn btn-secondary" id="friendBtn" style="border-color: #ffd700; color: #ffd700;">ðŸ‘¥
                    FRIENDS</button>
                <button class="game-btn btn-secondary" id="walletBtn" style="border-color: #ffd700; color: #fff;">ðŸ’°
                    STORE</button>
            </div>
        </div>

        <!-- 3D Stadium Canvas -->
        <canvas id="stadiumCanvas"></canvas>

        <div id="bottomBar" class="lobby-overlay">
            <button class="game-btn btn-secondary" id="leaveSquadBtn" style="display:none;">âŒ LEAVE</button>
            <button class="game-btn btn-secondary btn-ready" id="readyBtn" style="display:none;">READY</button>
            <button class="game-btn btn-secondary" id="emoteBtn">ðŸ˜Š EMOTES</button>
            <button class="game-btn btn-primary" id="startGameBtn">START RACE</button>
        </div>

        <!-- POPUP PANELS -->
        <div id="emotePanel" class="floating-panel">
            <button class="emote-btn" data-emote="wave">ðŸ‘‹ WAVE</button>
            <button class="emote-btn" data-emote="dance">ðŸ’ƒ DANCE</button>
            <button class="emote-btn" data-emote="laugh">ðŸ˜‚ LAUGH</button>
            <button class="emote-btn" data-emote="victory">ðŸ† WIN</button>
            <button class="emote-btn" data-emote="flex">ðŸ’ª FLEX</button>
            <button class="emote-btn" data-emote="salute">ðŸ«¡ SALUTE</button>
        </div>



        <!-- REDESIGNED SHOP MODAL (MARKETPLACE) -->
        <div id="shopModal">
            <div class="shop-container">
                <button class="close-shop" id="closeShopBtn">Ã—</button>

                <div class="shop-left">
                    <canvas id="shopCharCanvas"></canvas>
                </div>

                <div class="shop-right">
                    <div class="shop-header">
                        <h2 class="shop-title">STORE</h2>
                        <div class="shop-balance">
                            <span>ðŸ’°</span>
                            <span id="shopBalanceValue">0</span>
                        </div>
                    </div>

                    <div class="shop-tabs">
                        <div class="shop-tab active" data-tab="characters">CHARACTERS</div>
                        <div class="shop-tab" data-tab="outfits">OUTFITS</div>
                        <div class="shop-tab" data-tab="accessories">COLLECTION</div>
                    </div>

                    <div id="shopItemGrid" class="shop-grid">
                        <!-- Items populated by JS -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- GAME LOADING SCREEN -->
    <div id="gameLoader">
        <h2 style="color: #fff; font-size: 2rem;">ENTERING RACE...</h2>
        <p style="color: #888;">MATCHMAKING IN PROGRESS</p>
    </div>

    <!-- GAME UI (Placeholder) -->
    <div id="gameUI">
        <div id="joystick" style="position: absolute; bottom: 50px; left: 50px;"></div>
        <button id="pushBtn"
            style="position: absolute; bottom: 60px; right: 50px; padding: 20px 40px; border-radius: 50px; border: none; background: #ff3e7f; color: white; font-weight: bold; font-size: 1.2rem; box-shadow: 0 0 30px #ff3e7f;">BOOST</button>
    </div>

    <!-- FRIEND PANEL -->
    <div id="friendPanel">
        <div class="panel-header">
            <h2>ðŸ‘¥ SQUAD <span style="font-size:0.8rem; opacity:0.6; margin-left:10px;">ONLINE: <span
                        id="onlineCountRaw">0</span></span></h2>
            <button class="close-btn" id="closeFriendBtn">Ã—</button>
        </div>
        <div class="friend-tabs">
            <button class="f-tab active" data-tab="list">FRIENDS</button>
            <button class="f-tab" data-tab="req">REQUESTS <span id="reqBadge"
                    style="background:red; padding:2px 6px; border-radius:10px; font-size:0.7rem; display:none;">0</span></button>
            <button class="f-tab" data-tab="add">ADD</button>
        </div>
        <div class="friend-list" id="friendListContainer">
            <!-- Will be populated by JS -->
        </div>

        <!-- SEARCH UI (For ADD Tab) -->
        <div id="searchContainer">
            <div class="search-wrapper">
                <input type="text" class="search-input" id="playerSearchInput" placeholder="Find Agent...">
                <div class="search-icon">ðŸ”</div>
            </div>
            <div id="searchResults">
                <!-- Results go here -->
                <div style="text-align: center; color: #666; margin-top: 20px;">Type to search global agents...</div>
            </div>
        </div>

        <div class="panel-footer" id="defaultFooter">
            <!-- Only shown for non-search tabs if needed, or we keep it hidden for ADD tab -->
            <div class="add-friend-box">
                <input type="text" class="add-input" id="addFriendInput" placeholder="Quick Invite by Name...">
                <button class="add-btn-submit" id="addFriendSubmit">+</button>
            </div>
        </div>
    </div>

    <!-- INVITE POPUP (FREE FIRE STYLE) -->
    <div id="invitePopup">
        <div class="inv-left">
            <div class="inv-avatar">âš¡</div>
        </div>
        <div class="inv-right">
            <div class="inv-title">SQUAD INVITATION</div>
            <div class="inv-msg">
                <strong id="inviterName">NOOBMASTER69</strong> invites you to join their Ranked Lobby!
            </div>
            <div class="inv-actions">
                <button class="inv-btn inv-decline" id="popupDecline">REJECT</button>
                <button class="inv-btn inv-accept" id="popupAccept">JOIN TEAM</button>
            </div>
        </div>
    </div>

    <!-- SQUAD OVERLAY (For merged lobby) -->
    <div id="squadList"></div>

    <!-- Squad Members Panel (shows current squad) -->
    <div id="squadPanel"
        style="position: absolute; top: 100px; left: 30px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; min-width: 200px; display: none; z-index: 50;">
        <h3 style="color: #ffd700; margin: 0 0 10px 0; font-size: 1rem;">SQUAD MEMBERS</h3>
        <div id="squadMembersList"></div>
    </div>

    <!-- PROFILE MODAL (PREMIUM) -->
    <div id="profileModal">
        <div class="profile-container">
            <div class="corner corner-tl"></div>
            <div class="corner corner-tr"></div>
            <div class="corner corner-bl"></div>
            <div class="corner corner-br"></div>

            <button class="close-profile" id="closeProfileBtn">Ã—</button>

            <div class="profile-sidebar">
                <div class="side-tab active" data-content="overview">OVERVIEW</div>
                <div class="side-tab" data-content="stats">CAREER STATS</div>
                <div class="side-tab" data-content="history">MATCH HISTORY</div>
                <div class="side-tab" data-content="social">SOCIAL</div>
            </div>

            <div class="profile-main">
                <div class="profile-header-info">
                    <h2 class="prof-name" id="modalProfName">ANONYMOUS<span class="prof-badge">ELITE</span></h2>
                    <div class="prof-uid">UID: 295524894140</div>
                </div>

                <div id="profileContent">
                    <!-- Dynamic Content -->
                    <div class="stats-grid">
                        <div class="stat-card">
                            <span class="stat-value" id="statMatches">124</span>
                            <span class="stat-label">MATCHES</span>
                        </div>
                        <div class="stat-card">
                            <span class="stat-value" id="statWins">58</span>
                            <span class="stat-label">WINS</span>
                        </div>
                        <div class="stat-card">
                            <span class="stat-value" id="statWinRate">46%</span>
                            <span class="stat-label">WIN RATE</span>
                        </div>
                    </div>

                    <div class="rank-display">
                        <div class="rank-icon" id="profRankIcon">
                            <img src="ranks/bronze.png" alt="Rank">
                        </div>
                        <div class="rank-info">
                            <h3 id="profRankTitle">BRONZE I</h3>
                            <p id="profRankPoints">RANK POINTS: 0 / 1,000</p>
                        </div>
                    </div>

                    <div style="margin-top: 30px; border-top: 1px solid rgba(255,255,255,0.05); padding-top: 25px;">
                        <span
                            style="color: #888; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 2px;">Racing
                            Integrity</span>
                        <div
                            style="background: rgba(255,255,255,0.02); padding: 20px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); margin-top: 15px;">
                            <div
                                style="color: #666; font-size: 0.6rem; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 1px;">
                                Honor Score</div>
                            <div
                                style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; position: relative;">
                                <div id="profHonorBar"
                                    style="width: 100%; height: 100%; background: linear-gradient(90deg, #0f6, #00d4ff); border-radius: 3px; box-shadow: 0 0 15px rgba(0,255,100,0.4); transition: width 0.5s ease;">
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                                <span id="profHonorStatus"
                                    style="color: #0f6; font-size: 0.75rem; font-weight: bold; text-transform: uppercase;">STABLE</span>
                                <span id="profHonorValue"
                                    style="color: #fff; font-size: 0.75rem; font-weight: 800;">100/100</span>
                            </div>
                            <p style="color: #444; font-size: 0.6rem; margin: 10px 0 0 0; font-style: italic;">Penalty
                                for leaving mid-race: -5 Honor</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="profile-3d-view">
                <canvas id="profileCharCanvas"></canvas>
            </div>
        </div>
    </div>
    <style>
        /* Red Light Green Light Overlays */
        #gameBorderOverlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 50;
            transition: box-shadow 0.3s ease, background 0.3s ease;
        }

        .border-green {
            box-shadow: inset 0 0 50px 20px rgba(0, 255, 0, 0.5);
        }

        .border-red {
            box-shadow: inset 0 0 50px 20px rgba(255, 0, 0, 0.5);
        }

        .damage-overlay {
            background: rgba(0, 0, 0, 0.7);
            /* Darkens screen widely */
        }

        /* Health Display */
        #healthDisplay {
            position: fixed;
            top: 100px;
            right: 30px;
            z-index: 100;
            display: none;
            /* Shown in race */
            gap: 10px;
        }

        .heart {
            font-size: 2rem;
            color: #ff3e7f;
            filter: drop-shadow(0 0 5px rgba(255, 62, 127, 0.8));
            transition: opacity 0.3s, transform 0.3s;
        }

        .heart.broken {
            opacity: 0.2;
            transform: scale(0.8);
            filter: grayscale(1);
        }
    </style>
    <div id="gameBorderOverlay"></div>
    <div id="healthDisplay">
        <div class="heart" id="heart1">â¤ï¸</div>
        <div class="heart" id="heart2">â¤ï¸</div>
        <div class="heart" id="heart3">â¤ï¸</div>
    </div>
    <audio id="gameSong" src="song.mp3"></audio>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- FIREBASE IMPORTS (FIRESTORE) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import {
            getFirestore, collection, addDoc, setDoc, doc, onSnapshot, query, where, deleteDoc, getDocs, getDoc, updateDoc, serverTimestamp, increment
        } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        // --- FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyBOqZB3IxXVHTEsU3xTlNlQRrFP9zoEX8o",
            authDomain: "run-arena-1011.firebaseapp.com",
            projectId: "run-arena-1011",
            storageBucket: "run-arena-1011.firebasestorage.app",
            messagingSenderId: "295524894140",
            appId: "1:295524894140:web:17d6110a005cc7782997b9",
            measurementId: "G-W6WE817NMR"
        };

        // Initialize Firebase
        let app, db;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            console.log("Firestore Initialized");

            // Initialize Socket.IO - Connect to the backend server
            // For deployment: Frontend on Vercel, Backend on Fly.io
            // IMPORTANT: Replace 'classic-runner' with your actual Fly.io app name
            const SOCKET_SERVER_URL = 'https://classic-runner.fly.dev';
            window.socket = io(SOCKET_SERVER_URL);
            console.log(`Socket.IO Initialized - Connected to ${SOCKET_SERVER_URL}`);

            iziToast.success({
                title: 'READY',
                message: 'Firestore Connected!',
                position: 'topRight',
                timeout: 3000
            });

        } catch (e) {
            console.error("Firebase Init Error:", e);
            iziToast.warning({
                title: 'CONFIG ERROR',
                message: 'Check console for details.',
                timeout: 10000,
                position: 'topCenter'
            });
        }


        // --- STATE & CONFIG ---
        let selectedModelPath = "";
        let myUsername = "";
        let currentPlayers = 1;

        // --- RED LIGHT GREEN LIGHT STATE ---
        let redLightActive = false;
        let gameHealth = 3;
        let trackMixer = null;
        let trackAction = null;
        let damageCooldown = false;
        let safeTimeout = null;
        let dangerTimeout = null;

        // --- PRELOADER ANIMATION ---
        window.addEventListener('load', () => {
            // CHECK LOCAL STORAGE
            const savedName = localStorage.getItem('runArena_username');
            const savedModel = localStorage.getItem('runArena_model');

            if (savedName && savedModel) {
                console.log("Auto-login found:", savedName);
                myUsername = savedName;
                selectedModelPath = savedModel;

                // Skip animations, go straight to lobby
                document.getElementById('initialLoader').style.display = 'none';
                initLobby();
                return;
            }

            const tl = gsap.timeline();
            tl.to(".runner", { rotation: 360, duration: 1, repeat: 1, ease: "linear" })
                .to("#initialLoader", {
                    opacity: 0, duration: 0.8, ease: "power2.inOut", onComplete: () => {
                        document.getElementById('initialLoader').style.display = 'none';
                        initSelectionScreen();
                    }
                });
        });

        // --- PARTICLE DUST BACKGROUND ---
        function initGlobalParticles() {
            const canvas = document.getElementById('selectionParticles');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const particles = Array.from({ length: 100 }, () => ({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                speedX: (Math.random() - 0.5) * 0.5,
                speedY: (Math.random() - 0.5) * 0.5,
                alpha: Math.random()
            }));

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                particles.forEach(p => {
                    p.x += p.speedX;
                    p.y += p.speedY;
                    if (p.x < 0) p.x = canvas.width;
                    if (p.x > canvas.width) p.x = 0;
                    if (p.y < 0) p.y = canvas.height;
                    if (p.y > canvas.height) p.y = 0;

                    ctx.fillStyle = `rgba(0, 212, 255, ${p.alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                requestAnimationFrame(animate);
            }
            animate();
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }
        initGlobalParticles();

        // --- SELECTION SCREEN LOGIC ---
        function initSelectionScreen() {
            const selScreen = document.getElementById('characterSelect');
            selScreen.style.visibility = 'visible';
            gsap.to(selScreen, { opacity: 1, duration: 1 });

            // Initialize Character Previews
            document.querySelectorAll('.charOption').forEach((opt, index) => {
                const canvas = opt.querySelector('canvas');
                const modelPath = opt.dataset.model;

                // Three.js Preview Setup
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(35, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
                camera.position.set(0, 1, 5);

                const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);

                // Lights
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                const spot = new THREE.SpotLight(0xffffff, 2);
                spot.position.set(2, 5, 5);
                scene.add(ambient, spot);

                // Load Model
                const loader = new GLTFLoader();
                loader.load(modelPath, (gltf) => {
                    const model = gltf.scene;
                    model.position.y = -1.5;
                    scene.add(model);

                    const mixer = new THREE.AnimationMixer(model);
                    // Try to find idle animation
                    let idle = gltf.animations.find(a => a.name.toLowerCase().includes('idle')) || gltf.animations[0];
                    if (idle) mixer.clipAction(idle).play();

                    // Render Loop for Card
                    const clock = new THREE.Clock();
                    function renderCard() {
                        if (!opt.isConnected) return; // Stop if removed
                        requestAnimationFrame(renderCard);
                        const dt = clock.getDelta();
                        if (mixer) mixer.update(dt);

                        // Mild idle rotation
                        if (!opt.classList.contains('selected')) {
                            model.rotation.y = Math.sin(Date.now() * 0.001) * 0.3;
                        } else {
                            model.rotation.y += 0.02; // Spin when selected
                        }

                        renderer.render(scene, camera);
                    }
                    renderCard();

                    // Store mixer/model for interaction if needed
                    opt.userData = { model, mixer };

                });

                // Interaction
                opt.addEventListener('click', () => selectCharacter(opt, modelPath));
            });

            // Validate Input
            document.getElementById('usernameInput').addEventListener('input', validateSelection);
            const input = document.getElementById('usernameInput');

            input.addEventListener('click', () => {
                input.focus();
            });

        }

        function selectCharacter(optionElement, path) {
            document.querySelectorAll('.charOption').forEach(el => el.classList.remove('selected'));
            optionElement.classList.add('selected');
            selectedModelPath = path;

            // Pop Animation
            gsap.fromTo(optionElement, { scale: 0.9 }, { scale: 1.1, duration: 0.4, ease: "back.out(1.7)" });
            validateSelection();
        }

        function validateSelection() {
            const username = document.getElementById('usernameInput').value.trim();
            const btn = document.getElementById('continueBtn');

            if (username.length > 2 && selectedModelPath) {
                btn.disabled = false;
                myUsername = username;
                // previously saved here, now moved to after check
            } else {
                btn.disabled = true;
            }
        }

        // --- TRANSITION TO LOBBY ---
        // --- TRANSITION TO LOBBY ---
        document.getElementById('continueBtn').addEventListener('click', async () => {
            const btn = document.getElementById('continueBtn');
            const username = document.getElementById('usernameInput').value.trim();

            if (!username) return;

            // Security: Check if username already exists
            btn.disabled = true;
            btn.innerHTML = `<span>CHECKING...</span>`;

            try {
                // Normalize key for check
                const checkKey = username.replace(/[.#$/[\]]/g, "_").toLowerCase();
                if (!db) throw new Error("Database not connected");

                const docRef = doc(db, "all_users", checkKey);
                const docSnap = await getDoc(docRef);

                // If document exists, that means someone has claimed this username PERMANENTLY or it is reserved
                if (docSnap.exists()) {
                    iziToast.error({
                        title: 'TAKEN',
                        message: `The name '${username}' is already taken. Choose another!`,
                        position: 'topCenter'
                    });
                    btn.disabled = false;
                    btn.innerHTML = `<span>ENTER ARENA</span>`;
                    return;
                }

                // If unique, proceed
                const lobbyLoader = document.getElementById('lobbyLoader');
                lobbyLoader.style.display = 'flex';

                // Success - Save Session NOW
                localStorage.setItem('runArena_username', myUsername);
                localStorage.setItem('runArena_model', selectedModelPath);

                gsap.to('#characterSelect', {
                    opacity: 0,
                    y: -50,
                    duration: 0.8,
                    ease: "power2.in",
                    onComplete: () => {
                        document.getElementById('characterSelect').style.display = 'none';
                        initLobby();
                    }
                });

            } catch (error) {
                console.error("Uniqueness Check Failed:", error);
                // Fallback: allow entry if DB fails? Or block? Better block to be safe or warn.
                // For user experience, if DB is down, maybe let them in as temp? 
                // But user asked for security. Let's block and show error.
                iziToast.error({
                    title: 'ERROR',
                    message: 'Could not verify username. Try again.',
                    position: 'topCenter'
                });
                btn.disabled = false;
                btn.innerHTML = `<span>ENTER ARENA</span>`;
            }
        });

        // --- LOBBY LOGIC ---
        let stadiumScene, stadiumMixer, playerMesh, camera, renderer, clock;
        let loopStarted = false;

        // Clean up when entering initial lobby
        function initLobby() {
            // Don't show lobby div yet - wait for models to load
            setupStadiumThreeJS();

            // Register in Firebase now that we are "In Lobby"
            registerPlayerInDB(myUsername);
        }

        function setupStadiumThreeJS() {
            const canvas = document.getElementById('stadiumCanvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 200);

            // Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.8);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Additional lights for better visibility
            const spotLight1 = new THREE.SpotLight(0xffffff, 0.8);
            spotLight1.position.set(-20, 15, 0);
            scene.add(spotLight1);

            const spotLight2 = new THREE.SpotLight(0xffffff, 0.8);
            spotLight2.position.set(20, 15, 0);
            scene.add(spotLight2);

            // Camera looking at center
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 25);
            camera.lookAt(0, 2, 0);

            const loader = new GLTFLoader();
            let lobbyLoaded = false;
            let playerLoaded = false;

            // Load Lobby Model (looby.glb)
            console.log('Loading lobby model: assets/looby.glb');
            loader.load('assets/looby.glb', (gltf) => {
                const lobbyModel = gltf.scene;

                // Position lobby at origin
                lobbyModel.position.set(0, 0, 0);

                // Enable shadows on lobby
                lobbyModel.traverse(c => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });

                scene.add(lobbyModel);
                console.log('Lobby model loaded successfully!');
                window.lobbyModel = lobbyModel; // Store for removal later
                lobbyLoaded = true;

                // Hide loader if both are ready
                checkAndHideLoader();
            }, (progress) => {
                // Log and display loading progress
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                console.log(`Loading lobby: ${percent}%`);
                const loadingText = document.getElementById('lobbyLoadingText');
                if (loadingText) {
                    loadingText.textContent = `Loading Lobby... ${percent}%`;
                }
            }, (error) => {
                console.error('Error loading lobby model:', error);
                console.error('Failed path: assets/looby.glb');

                // DO NOT hide loader if it fails - show error instead
                const loadingText = document.getElementById('lobbyLoadingText');
                if (loadingText) {
                    loadingText.textContent = 'Failed to load lobby. Check console.';
                    loadingText.style.color = 'red';
                }
                // Keep loader visible to show the error
            });

            // Load Character Number for Initial Model
            const match = selectedModelPath.match(/character(\d+)\.glb/);
            const charNum = match ? match[1] : "1";
            const initialModelPath = `assets/ideal${charNum}.glb`;

            console.log(`Lobby: Loading character ${charNum} using ${initialModelPath}`);

            // Load Ideal Character at Center
            loader.load(initialModelPath, (gltf) => {
                playerMesh = gltf.scene;
                playerMesh.scale.set(2, 2, 2);

                // Position player at CENTER of the lobby
                playerMesh.position.set(0, 0, 0);

                // Face camera
                playerMesh.rotation.y = 0;

                playerMesh.traverse(c => { if (c.isMesh) c.castShadow = true; });
                scene.add(playerMesh);

                stadiumMixer = new THREE.AnimationMixer(playerMesh);

                if (gltf.animations && gltf.animations.length > 0) {
                    playerMesh.userData.idleClips = gltf.animations;
                    gltf.animations.forEach(clip => {
                        stadiumMixer.clipAction(clip).play();
                    });
                }

                // Intro drop animation
                gsap.from(playerMesh.position, { y: 20, duration: 1, ease: "bounce.out" });

                console.log('Player character loaded successfully!');
                playerLoaded = true;

                // Hide loader if both are ready
                checkAndHideLoader();
            }, undefined, (err) => {
                console.error("Failed to load ideal lobby model:", initialModelPath);
                iziToast.error({ message: "Character load failed!" });
            });

            function checkAndHideLoader() {
                // Hide loader only when BOTH lobby AND player are loaded
                if (lobbyLoaded && playerLoaded) {
                    const lobbyLoader = document.getElementById('lobbyLoader');
                    const lobbyDiv = document.getElementById('lobby');

                    // Hide the loader
                    gsap.to(lobbyLoader, {
                        opacity: 0,
                        duration: 0.5,
                        onComplete: () => {
                            lobbyLoader.style.display = 'none';
                        }
                    });

                    // Show the lobby
                    lobbyDiv.style.visibility = 'visible';
                    gsap.to(lobbyDiv, { opacity: 1, duration: 1 });
                }
            }

            // Loop Initialization
            if (!clock) clock = new THREE.Clock();
            stadiumScene = scene; // Save reference

            if (!loopStarted) {
                animate();
                loopStarted = true;
            }
        }

        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // --- FRIEND & INVITE SYSTEM ---
        const friendPanel = document.getElementById('friendPanel');
        const friendListContainer = document.getElementById('friendListContainer');
        const squadList = document.getElementById('squadList');

        let onlinePlayers = {};
        let myFriends = {}; // { key: { name: 'Bob' } }
        let friendRequests = []; // [ { id, from, fromName, timestamp } ]
        let myKey = null;
        let currentInviteId = null;

        // Open/Close Panel
        document.getElementById('friendBtn').addEventListener('click', () => {
            friendPanel.classList.add('active');
            // Default to list tab
            document.querySelector('.f-tab[data-tab="list"]').click();
        });
        document.getElementById('closeFriendBtn').addEventListener('click', () => {
            friendPanel.classList.remove('active');
        });

        // Toggle Tabs
        document.querySelectorAll('.f-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                const target = e.target.closest('.f-tab');
                if (!target) return;

                document.querySelectorAll('.f-tab').forEach(t => t.classList.remove('active'));
                target.classList.add('active');

                const tabName = target.dataset.tab;

                const listC = document.getElementById('friendListContainer');
                const searchC = document.getElementById('searchContainer');
                const footer = document.getElementById('defaultFooter');

                if (tabName === 'list') {
                    listC.style.display = 'block';
                    searchC.style.display = 'none';
                    footer.style.display = 'none'; // No "quick add" footer needed
                    updateFriendListUI();
                } else if (tabName === 'req') {
                    listC.style.display = 'block';
                    searchC.style.display = 'none';
                    footer.style.display = 'none';
                    updateRequestsUI();
                } else if (tabName === 'add') {
                    listC.style.display = 'none';
                    searchC.style.display = 'flex';
                    footer.style.display = 'block'; // âœ… SHOW add input
                }

            });
        });

        let mySquadId = "";

        // FIREBASE REGISTRATION & LISTENERS
        async function registerPlayerInDB(username) {
            if (!db) return;

            // Simple key generation (Case Insensitive)
            myKey = username.replace(/[.#$/[\]]/g, "_").toLowerCase();

            // Check if player already exists in current session to preserve squadId
            let existingSquadId = myKey; // Default to own squad
            try {
                const existingPlayer = await getDoc(doc(db, "players", myKey));
                if (existingPlayer.exists() && existingPlayer.data().squadId) {
                    existingSquadId = existingPlayer.data().squadId;
                    console.log(`Preserving existing squadId: ${existingSquadId}`);
                }
            } catch (e) {
                console.log("No existing session, creating new");
            }

            mySquadId = existingSquadId;

            const myData = {
                name: username,
                status: 'online',
                avatar: "ðŸ‘¤",
                model: selectedModelPath,
                lastSeen: Date.now(),
                squadId: existingSquadId,  // Use preserved or default
                emote: { type: "", time: 0 }
            };

            // 1. Set my data in 'players' collection (Online Status)
            try {
                await setDoc(doc(db, "players", myKey), myData);
                console.log("Player Registered (Online)");
            } catch (e) { console.error("Error adding player:", e); }

            // 2. Set PERMANENT data in 'all_users'
            try {
                // Initialize/Sync all_users document
                let initialHonor = 100;
                let penaltyApplied = false;

                const userDocRef = doc(db, "all_users", myKey);
                const snap = await getDoc(userDocRef);

                if (snap.exists()) {
                    const data = snap.data();
                    // PENALTY CHECK: If they left mid-race last time
                    if (data.lastRaceActive === true) {
                        initialHonor = Math.max(0, (data.honorScore || 100) - 5);
                        penaltyApplied = true;
                    } else {
                        initialHonor = data.honorScore !== undefined ? data.honorScore : 100;
                    }
                }

                await setDoc(userDocRef, {
                    name: username, // Display name preserves case
                    avatar: "ðŸ‘¤",
                    lastLogin: serverTimestamp(),
                    matches: increment(0),
                    wins: increment(0),
                    rankPoints: increment(0),
                    honorScore: initialHonor,
                    lastRaceActive: false // Reset flag on login
                }, { merge: true });

                if (penaltyApplied) {
                    iziToast.warning({
                        title: 'HONOR PENALTY',
                        message: 'Detected mid-race disconnection. -5 Honor.',
                        position: 'topRight',
                        timeout: 5000
                    });
                }
                console.log("Player Archived (Perm)");
            } catch (e) { console.error("Error archiving user:", e); }

            // --- HEARTBEAT SYSTEM ---
            setInterval(async () => {
                if (db && myKey) {
                    try {
                        await updateDoc(doc(db, "players", myKey), {
                            lastSeen: serverTimestamp()
                        });
                    } catch (e) {
                        console.error("Heartbeat failed:", e);
                    }
                }
            }, 20000); // Every 20 seconds


            // 3. Remove on Window Close (Manual Heartbeat)
            window.addEventListener('beforeunload', async () => {
                // Reset squadId to solo before leaving
                try {
                    await updateDoc(doc(db, "players", myKey), {
                        squadId: myKey
                    });
                } catch (e) { console.log(e); }

                // Delete player document
                deleteDoc(doc(db, "players", myKey));
            });


            // 4. Listen for all ONLINE players
            const playersRef = collection(db, "players");
            let lastSquadId = null;

            onSnapshot(playersRef, (snapshot) => {
                onlinePlayers = {};
                const now = Date.now();
                const timeoutThreshold = 60000; // 60 seconds

                snapshot.forEach(doc => {
                    const data = doc.data();
                    const lastSeen = data.lastSeen?.toMillis ? data.lastSeen.toMillis() : (data.lastSeen || 0);

                    // Only count as online if seen in the last 60 seconds
                    if (now - lastSeen < timeoutThreshold) {
                        onlinePlayers[doc.id.toLowerCase()] = data;
                    }
                });

                // Periodic UI Refresh to prune timed-out players without DB changes
                if (!window.presenceRefreshInterval) {
                    window.presenceRefreshInterval = setInterval(() => {
                        console.log("Pruning stale players...");
                        const refreshNow = Date.now();
                        let changed = false;
                        Object.keys(onlinePlayers).forEach(key => {
                            const p = onlinePlayers[key];
                            const pLastSeen = p.lastSeen?.toMillis ? p.lastSeen.toMillis() : (p.lastSeen || 0);
                            if (refreshNow - pLastSeen > timeoutThreshold) {
                                delete onlinePlayers[key];
                                changed = true;
                            }
                        });
                        if (changed) {
                            updateSquadSync();
                            updateSquadPanel();
                            updateFriendListUI();
                        }
                    }, 30000);
                }

                // Detect Squad Change
                const currentSquadId = onlinePlayers[myKey]?.squadId;
                if (currentSquadId && currentSquadId !== lastSquadId) {
                    console.log(`ðŸ”„ Squad Changed: ${lastSquadId} -> ${currentSquadId}`);
                    lastSquadId = currentSquadId;
                    mySquadId = currentSquadId;
                    setupRaceSignalListener(currentSquadId);
                }

                // --- REAL-TIME SQUAD SYNC ---
                updateSquadSync();
                updateSquadPanel();
                updateStartButtonState();
                updateReadyButtonUI();
                syncPositionInRace();

                // Update UI if on list tab
                const activeTab = document.querySelector('.f-tab.active');
                if (activeTab && activeTab.dataset.tab === 'list') {
                    updateFriendListUI();
                }

                // Update count
                const count = Object.keys(onlinePlayers).length;
                // Old counter removed as per user request
                const onlineCountEl = document.getElementById('onlineCountRaw');
                if (onlineCountEl) onlineCountEl.innerText = count > 0 ? count - 1 : 0;
            });

            // setupRaceSignalListener locally defined to use global unsub
            let raceSignalUnsub = null;
            function setupRaceSignalListener(squadId) {
                if (raceSignalUnsub) {
                    console.log('ðŸ”‡ Unsubscribing from old race signals');
                    raceSignalUnsub();
                }

                if (!squadId || !db) return;
                console.log('ðŸ Listening for race signals on squad:', squadId);

                raceSignalUnsub = onSnapshot(doc(db, "race_signals", squadId), (snapshot) => {
                    if (snapshot.exists()) {
                        const data = snapshot.data();
                        console.log('ðŸ“¡ Signal received:', data);

                        if (data.action === 'start' && data.players && data.players.includes(myKey)) {
                            console.log('âœ… Team Start! My lane:', data.players.indexOf(myKey));
                            startRaceForPlayer(data.players.indexOf(myKey));
                            // Delete signal after delay
                            if (myKey === squadId) {
                                setTimeout(() => { deleteDoc(doc(db, "race_signals", squadId)).catch(e => console.log(e)); }, 3000);
                            }
                        }
                    }
                });
            }

            // 5. Listen for FRIEND REQUESTS (Incoming)
            const reqRef = query(collection(db, "friend_requests"), where("to", "==", myKey), where("status", "==", "pending"));
            onSnapshot(reqRef, (snapshot) => {
                friendRequests = [];
                snapshot.forEach(doc => {
                    friendRequests.push({ id: doc.id, ...doc.data() });
                });

                // Update Badge
                const badge = document.getElementById('reqBadge');
                if (badge) {
                    badge.innerText = friendRequests.length;
                    badge.style.display = friendRequests.length > 0 ? 'inline-block' : 'none';
                }

                // Update UI if on Req tab
                const activeTab = document.querySelector('.f-tab.active');
                if (activeTab && activeTab.dataset.tab === 'req') {
                    updateRequestsUI();
                }
            });

            // 6. Listen for MY FRIEND LIST
            const myFriendsRef = collection(db, `users/${myKey}/friends`);
            onSnapshot(myFriendsRef, (snapshot) => {
                myFriends = {};
                snapshot.forEach(doc => {
                    // Force lowercase local key
                    myFriends[doc.id.toLowerCase()] = doc.data();
                });

                // Update UI if on list tab
                const activeTab = document.querySelector('.f-tab.active');
                if (activeTab && activeTab.dataset.tab === 'list') {
                    updateFriendListUI();
                }
            });

            // 7. Listen for Invites sent TO me
            const q = query(collection(db, "invites"), where("to", "==", myKey));
            onSnapshot(q, (snapshot) => {
                let latestInvite = null;
                let latestId = null;

                snapshot.forEach((doc) => {
                    latestInvite = doc.data();
                    latestId = doc.id;
                });

                if (latestInvite) {
                    showInvitePopup(latestInvite.fromName, latestId, latestInvite.from);
                }
            });
        }

        // Render Friend List (Accepted Friends Only)
        function updateFriendListUI() {
            if (!friendListContainer) return;
            friendListContainer.innerHTML = '';

            const friendsKeys = Object.keys(myFriends);

            if (friendsKeys.length === 0) {
                friendListContainer.innerHTML = `<div style="text-align:center; padding:20px; color:#888;">No friends yet.<br>Go to ADD tab to find agents!</div>`;
                return;
            }

            friendsKeys.forEach(fKey => {
                const fData = myFriends[fKey];
                // Case-insensitive lookup for status
                const lookupKey = fKey.toLowerCase();
                const isOnline = onlinePlayers[lookupKey] ? true : false;
                const statusText = isOnline ? 'ONLINE' : 'OFFLINE';

                // Get avatar from online player data if available, else generic
                const avatar = isOnline ? onlinePlayers[lookupKey].avatar : "ðŸ‘¤";

                const isSameSquad = onlinePlayers[lookupKey] && onlinePlayers[lookupKey].squadId === mySquadId && mySquadId;
                const finalStatus = isSameSquad ? 'IN SQUAD' : statusText;
                const finalStatusClass = isSameSquad ? 'color: #ffd700;' : '';

                const item = document.createElement('div');
                item.className = `friend-item ${isOnline ? 'online' : ''}`;
                item.innerHTML = `
                    <div class="f-avatar ${isOnline ? 'online' : ''}">${avatar}</div>
                    <div class="f-info">
                        <span class="f-name">${fData.name}</span>
                        <span class="f-status" style="${finalStatusClass}">${finalStatus}</span>
                    </div>
                    <div class="f-actions">
                        ${isOnline
                        ? (isSameSquad
                            ? `<button class="f-btn" style="color:#ffd700; cursor:default;" title="In Squad">ðŸ›¡ï¸</button>`
                            : `<button class="f-btn btn-invite" onclick="sendInvite('${lookupKey}', '${fData.name}')" title="Invite to Lobby">ðŸ“©</button>`)
                        : `<button class="f-btn" style="opacity:0.3; cursor:default;" title="Offline">â›”</button>`
                    }
                    </div>
                `;
                friendListContainer.appendChild(item);
            });
        }

        // Render Friend Requests
        function updateRequestsUI() {
            if (!friendListContainer) return;
            friendListContainer.innerHTML = '';

            if (friendRequests.length === 0) {
                friendListContainer.innerHTML = `<div style="text-align:center; padding:50px; color:#666;">No pending requests.</div>`;
                return;
            }

            // Deduplicate requests by sender (just in case DB has dupes)
            const uniqueReqs = [];
            const seenSenders = new Set();
            friendRequests.forEach(req => {
                if (!seenSenders.has(req.from)) {
                    seenSenders.add(req.from);
                    uniqueReqs.push(req);
                }
            });

            uniqueReqs.forEach(req => {
                const item = document.createElement('div');
                item.className = 'friend-item';
                item.innerHTML = `
                    <div class="f-avatar">ðŸ‘‹</div>
                    <div class="f-info">
                        <span class="f-name">${req.fromName}</span>
                        <span class="f-status">WANTS TO BE FRIENDS</span>
                    </div>
                    <div class="f-actions">
                         <button class="f-btn btn-invite" onclick="acceptFriendRequest('${req.id}', '${req.from}', '${req.fromName}')" style="background: #ffd700; color: #000;" title="Accept">âœ”</button>
                         <button class="f-btn btn-remove" onclick="rejectFriendRequest('${req.id}')" title="Decline" style="display:flex;">âœ–</button>
                    </div>
                `;
                friendListContainer.appendChild(item);
            });
        }

        // --- SEARCH LOGIC ---
        let allUsersCache = {};

        // Listen to all_users for search
        function initSearchListeners() {
            if (!db) return;
            const usersRef = collection(db, 'all_users');
            onSnapshot(usersRef, (snapshot) => {
                allUsersCache = {};
                snapshot.forEach(doc => {
                    allUsersCache[doc.id] = doc.data();
                });
            });
        }
        // Call it
        setTimeout(initSearchListeners, 2000); // Small delay to ensure db ready

        document.getElementById('playerSearchInput').addEventListener('input', (e) => {
            const query = e.target.value.trim().toLowerCase();
            const resultsDiv = document.getElementById('searchResults');
            resultsDiv.innerHTML = '';

            if (query.length === 0) {
                resultsDiv.innerHTML = `<div style="text-align: center; color: #666; margin-top: 20px;">Type to search global agents...</div>`;
                return;
            }

            const matches = Object.keys(allUsersCache).filter(key => {
                const u = allUsersCache[key];
                return u.name.toLowerCase().startsWith(query);
            });

            if (matches.length === 0) {
                resultsDiv.innerHTML = `<div style="text-align: center; color: #888; margin-top: 20px;">No agents found.</div>`;
                return;
            }

            matches.forEach(key => {
                if (key === myKey) return; // Skip self
                const u = allUsersCache[key];
                const div = document.createElement('div');
                div.className = 'result-item';
                // Check if already friend
                const isFriend = myFriends[key] ? true : false;

                div.innerHTML = `
                    <div class="f-avatar">${u.avatar}</div>
                    <div class="r-name">${u.name}</div>
                    ${isFriend
                        ? `<span style="color:#0f0; margin-right:10px;">FRIEND</span>`
                        : `<button class="btn-add" onclick="sendFriendRequest('${key}', '${u.name}')" title="Send Friend Request">+</button>`
                    }
                 `;
                resultsDiv.appendChild(div);
            });
        });

        // --- FRIEND REQUEST LOGIC ---
        window.sendFriendRequest = async (targetKey, targetName) => {
            if (!db) return;

            // Normalize key
            targetKey = targetKey.toLowerCase();

            // 1. Check if already friends locally
            if (myFriends[targetKey]) {
                iziToast.warning({ message: `You are already friends with ${targetName}.` });
                return;
            }

            try {
                // 2. Check if a request is ALREADY pending (to avoid spam)
                const q = query(
                    collection(db, "friend_requests"),
                    where("from", "==", myKey),
                    where("to", "==", targetKey),
                    where("status", "==", "pending")
                );
                const snapshot = await getDocs(q);

                if (!snapshot.empty) {
                    iziToast.warning({ message: `Request to ${targetName} is already pending!` });
                    return;
                }

                // 3. Send Request
                await addDoc(collection(db, "friend_requests"), {
                    from: myKey,
                    fromName: myUsername,
                    to: targetKey,
                    toName: targetName,
                    status: 'pending',
                    timestamp: Date.now()
                });
                iziToast.success({ title: 'SENT', message: `Friend request sent to ${targetName}` });
            } catch (e) {
                console.error(e);
                iziToast.error({ message: 'Failed to send request' });
            }
        };

        window.acceptFriendRequest = async (reqId, senderKey, senderName) => {
            if (!db) return;

            senderKey = senderKey.toLowerCase();

            try {
                // 1. Add to MY friends
                await setDoc(doc(db, `users/${myKey}/friends/${senderKey}`), {
                    name: senderName,
                    since: Date.now()
                });

                // 2. Add ME to THEIR friends (Mutual)
                // Note: In secure app, this should be backend function or specific rules, 
                // but for this demo we write to their path if allowed.
                await setDoc(doc(db, `users/${senderKey}/friends/${myKey}`), {
                    name: myUsername,
                    since: Date.now()
                });

                // 3. Delete Request
                await deleteDoc(doc(db, "friend_requests", reqId));

                iziToast.success({ title: 'ADDED', message: `You are now friends with ${senderName}!` });
            } catch (e) {
                console.error(e);
                iziToast.error({ message: 'Error accepting friend.' });
            }
        };

        window.rejectFriendRequest = async (reqId) => {
            try {
                await deleteDoc(doc(db, "friend_requests", reqId));
                iziToast.show({ message: 'Request removed.' });
            } catch (e) { console.error(e); }
        };

        // --- LOBBY INVITE LOGIC ---
        window.sendInvite = async (targetKey, targetName) => {
            if (!db) {
                iziToast.error({ title: 'ERROR', message: 'Database not connected.' });
                return;
            }

            targetKey = targetKey.toLowerCase();

            // Check if player is actually online?
            const isOnline = onlinePlayers[targetKey];
            if (!isOnline) {
                iziToast.warning({ message: `${targetName} is offline.` });
                return;
            }

            try {
                const inviteData = {
                    from: myKey,
                    fromName: myUsername,
                    to: targetKey,
                    timestamp: Date.now()
                };
                await addDoc(collection(db, "invites"), inviteData);

                iziToast.info({
                    title: 'INVITE SENT',
                    message: `Invited ${targetName} to lobby!`,
                    position: 'topCenter'
                });
            } catch (e) {
                console.error(e);
                iziToast.error({ title: 'ERROR', message: 'Failed to send invite.' });
            }
        };

        const invitePopup = document.getElementById('invitePopup');

        function showInvitePopup(inviterName, inviteId, fromKey) {
            document.getElementById('inviterName').innerText = inviterName;
            invitePopup.classList.add('active');
            currentInviteId = inviteId;
            invitePopup.dataset.fromKey = fromKey; // Store sender key
        }

        document.getElementById('popupDecline').addEventListener('click', () => {
            invitePopup.classList.remove('active');
            // Remove invite from DB
            if (currentInviteId) {
                deleteDoc(doc(db, "invites", currentInviteId));
            }
            iziToast.error({ title: 'REJECTED', message: 'You declined the invitation.' });
        });

        document.getElementById('popupAccept').addEventListener('click', () => {
            invitePopup.classList.remove('active');

            // Remove invite from DB
            if (currentInviteId) {
                deleteDoc(doc(db, "invites", currentInviteId));
            }

            iziToast.success({ title: 'JOINING', message: `Joining ${document.getElementById('inviterName').innerText}'s lobby...` });

            // Visual Merge (Old hardcoded way, will be replaced by reactive sync)
            squadList.innerHTML = '';
            addToSquad(document.getElementById('inviterName').innerText + " (Leader)");
            addToSquad(myUsername);

            document.getElementById('startGameBtn').innerText = "START RACE";

            // SYNC SQUAD TO DB
            const fromKey = invitePopup.dataset.fromKey;
            if (fromKey && db && myKey) {
                mySquadId = fromKey;
                updateDoc(doc(db, "players", myKey), { squadId: fromKey });
            }

            // No longer calling spawnSquadMember manually here, 
            // the reactive listener will handle it.
        });

        const squadMeshes = {}; // { key: { scene, mixer, lastEmoteTime, modelPath } }

        function updateSquadSync() {
            if (!myKey || !mySquadId) return;

            // 1. Sync Squad UI List
            const squadList = document.getElementById('squadList');
            if (squadList) {
                squadList.innerHTML = '';
                // Add leader first (in a real system we'd check roles, here leader is mySquadId)
                const leaderData = onlinePlayers[mySquadId];
                if (leaderData) addToSquad(leaderData.name + " (Leader)");

                // Add others
                Object.keys(onlinePlayers).forEach(key => {
                    if (onlinePlayers[key].squadId === mySquadId && key !== mySquadId) {
                        addToSquad(onlinePlayers[key].name);
                    }
                });
            }

            // 2. Identify members for 3D view
            const squadMembers = Object.keys(onlinePlayers).filter(key =>
                onlinePlayers[key].squadId === mySquadId && key !== myKey
            );

            // 3. Remove players who left
            Object.keys(squadMeshes).forEach(key => {
                if (!squadMembers.includes(key)) {
                    console.log(`Removing ${key} from scene`);
                    stadiumScene.remove(squadMeshes[key].scene);
                    delete squadMeshes[key];
                }
            });

            // 4. Add/Update members
            squadMembers.forEach((key, index) => {
                const data = onlinePlayers[key];
                if (!squadMeshes[key]) {
                    spawnSquadMember(key, data.model, index + 1);
                } else {
                    // Update position if NOT in race mode (in lobby we use index-based spawning)
                    // In race mode, the animate loop handles position sync
                    if (!window.raceMode) {
                        // Keep them in lobby spots if needed
                    }

                    // Check for emote sync
                    if (data.emote && data.emote.time > (squadMeshes[key].lastEmoteTime || 0)) {
                        squadMeshes[key].lastEmoteTime = data.emote.time;
                        handleRemoteEmote(key, data.emote.type);
                    }
                }
            });
        }

        async function handleRemoteEmote(key, type) {
            const member = squadMeshes[key];
            if (!member || !type) return;

            // Extract char num
            const match = member.modelPath.match(/character(\d+)/);
            const num = match ? match[1] : "1";

            let emoteUrl = "";
            if (type === 'wave') emoteUrl = `assets/hi${num}.glb`;
            else if (type === 'laugh') emoteUrl = `assets/laugh${num}.glb`;
            else if (type === 'victory') emoteUrl = `assets/win${num}.glb`;
            else if (type === 'salute') emoteUrl = `assets/salute${num}.glb`;
            else if (type === 'flex') emoteUrl = `assets/flex${num}.glb`;
            else if (type === 'dance') emoteUrl = `assets/dance${num}.glb`;

            if (!emoteUrl) return;

            const loader = new GLTFLoader();
            loader.load(emoteUrl, (gltf) => {
                if (!gltf.animations || gltf.animations.length === 0) return;

                // Create a temporary emote mesh for the remote player
                const emoteScene = gltf.scene;
                emoteScene.position.copy(member.scene.position);
                emoteScene.rotation.copy(member.scene.rotation);
                emoteScene.scale.set(2, 2, 2);

                member.scene.visible = false;
                stadiumScene.add(emoteScene);

                const mixer = new THREE.AnimationMixer(emoteScene);

                // Play ALL animations from the GLB file
                let maxDuration = 0;
                gltf.animations.forEach((clip) => {
                    const action = mixer.clipAction(clip);
                    action.loop = THREE.LoopOnce;
                    action.clampWhenFinished = true;
                    action.play();

                    if (clip.duration > maxDuration) {
                        maxDuration = clip.duration;
                    }
                });

                // Mixer update loop for this emote
                const startTime = performance.now();
                const animate = (time) => {
                    if (!emoteScene.parent) return;
                    const dt = (time - startTime) / 1000;
                    mixer.update(0.016);
                    if (dt < maxDuration + 0.5) requestAnimationFrame(animate);
                    else {
                        stadiumScene.remove(emoteScene);
                        if (squadMeshes[key]) {
                            const sm = squadMeshes[key];
                            sm.scene.visible = true;
                            // Resume idle
                            if (sm.scene.userData.idleClips && sm.mixer) {
                                sm.scene.userData.idleClips.forEach(clip => {
                                    sm.mixer.clipAction(clip).reset().play();
                                });
                            }
                        }
                    }
                };
                requestAnimationFrame(animate);
            });
        }

        function spawnSquadMember(key, modelPath, index) {
            if (squadMeshes[key]) return;

            const loader = new GLTFLoader();
            loader.load(modelPath, (gltf) => {
                const member = gltf.scene;

                // Position pattern: Left, Right, Right-further, Left-further, etc.
                // Index 1: -2.5 (left)
                // Index 2: +2.5 (right)  
                // Index 3: +5.0 (right further)
                // Index 4: -5.0 (left further)
                let xPos;
                if (index === 1) {
                    xPos = -2.5; // First member: LEFT
                } else if (index === 2) {
                    xPos = 2.5;  // Second member: RIGHT
                } else {
                    // Third and beyond: continue alternating, spreading outward
                    const isLeft = index % 2 === 1; // Odd indices go left, even go right
                    const distanceMultiplier = Math.floor(index / 2);
                    xPos = isLeft ? -(distanceMultiplier * 2.5) : (distanceMultiplier * 2.5);
                }

                member.position.set(xPos, 0, 0);
                member.scale.set(2, 2, 2);
                stadiumScene.add(member);

                // Identify Character Number
                const match = modelPath.match(/character(\d+)/);
                const charNum = match ? match[1] : "1";

                // DECIDE MODEL: ideal for lobby, character for race
                const finalModelPath = window.raceMode ? modelPath : `assets/ideal${charNum}.glb`;

                console.log(`Squad Member: Loading character ${charNum} for ${window.raceMode ? 'RACE' : 'LOBBY'}`);

                loader.load(finalModelPath, (gltf) => {
                    // Replace the initial member scene with the final one
                    stadiumScene.remove(member);
                    const scene = gltf.scene;

                    if (window.raceMode) {
                        // Lane assignment positioning
                        const laneOffsets = [-15.4, -5.3, 6.6, 16.6];
                        const xPos = laneOffsets[index % 4];
                        scene.position.set(xPos, 0, -73);
                        scene.scale.set(1.5, 1.5, 1.5); // Slightly smaller for race track scale if needed
                    } else {
                        scene.position.copy(member.position);
                        scene.scale.set(2, 2, 2);
                    }

                    stadiumScene.add(scene);

                    if (window.raceMode) {
                        const activeClip = gltf.animations.find(a => a.name.toLowerCase().includes('run')) || gltf.animations[0];
                        if (activeClip) {
                            mixer.clipAction(activeClip).play();
                            scene.userData.idleClips = [activeClip];
                        }
                    } else {
                        if (gltf.animations && gltf.animations.length > 0) {
                            scene.userData.idleClips = gltf.animations;
                            gltf.animations.forEach(clip => {
                                mixer.clipAction(clip).play();
                            });
                        }
                    }

                    squadMeshes[key] = {
                        scene: scene,
                        mixer: mixer,
                        lastEmoteTime: Date.now(),
                        modelPath: modelPath
                    };
                });
            });
        }

        // Function updates UI when someone joins
        function addToSquad(name) {
            const card = document.createElement('div');
            card.className = 'squad-card';
            card.innerHTML = `
                <div class="sq-avatar"></div>
                <div>
                   <div class="sq-name">${name}</div>
                   <div class="sq-status">READY</div>
                </div>
            `;
            squadList.appendChild(card);
        }

        // --- GLOBAL EXPORTS (for HTML onclick) ---
        // window.sendInvite is defined above

        // --- EMOTE SYSTEM (Existing) ---
        document.getElementById('emoteBtn').addEventListener('click', toggleEmotePanel);

        function toggleEmotePanel() {
            const p = document.getElementById('emotePanel');
            const isHidden = getComputedStyle(p).visibility === 'hidden';

            if (isHidden) {
                gsap.set(p, { visibility: 'visible', y: 20, opacity: 0 });
                gsap.to(p, { y: 0, opacity: 1, duration: 0.3 });
            } else {
                gsap.to(p, { y: 20, opacity: 0, duration: 0.2, onComplete: () => p.style.visibility = 'hidden' });
            }
        }

        // Emote Buttons
        document.querySelectorAll('.emote-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const type = e.target.dataset.emote;
                handleEmote(type);
            });
        });

        function handleEmote(type) {
            if (!playerMesh || !stadiumMixer) {
                console.error('PlayerMesh or stadiumMixer not ready');
                return;
            }

            // --- SYNC EMOTE TO NETWORK ---
            if (db && myKey) {
                updateDoc(doc(db, "players", myKey), {
                    emote: { type, time: Date.now() }
                }).catch(e => console.error("Sync error:", e));
            }

            // Determine file path
            // Extract char num from selectedModelPath: "assets/character5.glb" -> "5"
            const match = selectedModelPath.match(/character(\d+)/);
            const num = match ? match[1] : "1";

            console.log('Selected character number:', num);
            console.log('Selected model path:', selectedModelPath);

            let emoteUrl = "";
            let emoteName = "";

            // logic user requested: if characterN, run hiN.glb, laughN.glb, winN.glb, or saluteN.glb
            if (type === 'wave') {
                emoteUrl = `assets/hi${num}.glb`;
                emoteName = 'Wave';
                console.log('Wave emote requested. Loading file:', emoteUrl);
            }
            else if (type === 'laugh') {
                emoteUrl = `assets/laugh${num}.glb`;
                emoteName = 'Laugh';
                console.log('Laugh emote requested. Loading file:', emoteUrl);
            }
            else if (type === 'flex') {
                emoteUrl = `assets/flex${num}.glb`;
                emoteName = 'Flex';
                console.log('Flex emote requested. Loading file:', emoteUrl);
            }
            else if (type === 'victory') {
                emoteUrl = `assets/win${num}.glb`;
                emoteName = 'Win';
                console.log('Win emote requested. Loading file:', emoteUrl);
            }
            else if (type === 'salute') {
                emoteUrl = `assets/salute${num}.glb`;
                emoteName = 'Salute';
                console.log('Salute emote requested. Loading file:', emoteUrl);
            }
            else if (type === 'dance') {
                emoteUrl = `assets/dance${num}.glb`;
                emoteName = 'Dance';
                console.log('Dance emote requested. Loading file:', emoteUrl);
            } else {
                iziToast.show({ message: `${type.toUpperCase()} emote triggered (placeholder)!`, color: 'blue' });
                return;
            }

            // CLEANUP PREVIOUS EMOTE IF RUNNING
            if (window.activeEmoteScene) {
                console.log('ðŸ§¹ Cleaning up previous emote...');
                stadiumScene.remove(window.activeEmoteScene);
                window.activeEmoteScene = null;

                if (window.activeEmoteMixer) {
                    window.activeEmoteMixer.stopAllAction();
                    window.activeEmoteMixer = null;
                }

                playerMesh.visible = true; // Briefly show player to avoid flickering if next load is slow
            }

            // Load and Play - ANIMATION RETARGETING STRATEGY (with fallback to swap)
            if (emoteUrl) {
                console.log('Attempting to load emote file:', emoteUrl);
                const loader = new GLTFLoader();
                loader.load(emoteUrl, (gltf) => {
                    console.log('âœ… Successfully loaded emote file:', emoteUrl);

                    // CHECK AGAIN: If user clicked another emote while this was loading, ABORT
                    // However, for simplicity, we just run the cleanup again here inside the callback to be safe
                    if (window.activeEmoteScene) {
                        stadiumScene.remove(window.activeEmoteScene);
                        window.activeEmoteScene = null;
                        if (window.activeEmoteMixer) window.activeEmoteMixer.stopAllAction();
                    }

                    if (!gltf.animations || gltf.animations.length === 0) {
                        console.warn("No animations found in " + emoteUrl);
                        iziToast.error({ message: "No animation in emote file!" });
                        return;
                    }

                    console.log(`âœ… Found ${gltf.animations.length} animations in emote file`);

                    // SIMPLIFIED MODEL SWAP STRATEGY
                    const emoteScene = gltf.scene;

                    // Position and Rotate EXACTLY where player is
                    emoteScene.position.copy(playerMesh.position);
                    emoteScene.rotation.copy(playerMesh.rotation);
                    emoteScene.scale.copy(playerMesh.scale);

                    // Make sure meshes are visible
                    emoteScene.traverse(c => {
                        if (c.isMesh) {
                            c.castShadow = true;
                            c.receiveShadow = true;
                            c.visible = true;
                        }
                    });

                    // Hide main player
                    playerMesh.visible = false;

                    // Add emote to scene
                    stadiumScene.add(emoteScene);
                    emoteScene.visible = true;

                    // TRACK CURRENT EMOTE SCENE
                    window.activeEmoteScene = emoteScene;

                    // Create mixer and play ALL animations simultaneously
                    const emoteMixer = new THREE.AnimationMixer(emoteScene);

                    // Play ALL animations from the GLB file
                    const actions = [];
                    let maxDuration = 0;
                    let longestClip = null;

                    gltf.animations.forEach((clip, index) => {
                        console.log(`Playing animation ${index + 1}/${gltf.animations.length}: ${clip.name}`);
                        const action = emoteMixer.clipAction(clip);
                        action.clampWhenFinished = true;
                        action.loop = THREE.LoopOnce;
                        action.reset();
                        action.play();
                        actions.push(action);

                        // Track the longest animation duration
                        if (clip.duration > maxDuration) {
                            maxDuration = clip.duration;
                            longestClip = clip;
                        }
                    });

                    // Store in global
                    window.activeEmoteMixer = emoteMixer;

                    iziToast.success({
                        message: `${emoteName} emote playing!`,
                        position: 'topRight',
                        timeout: (maxDuration || 2) * 1000
                    });

                    // Cleanup when animation finishes
                    const onFinished = (e) => {
                        // ONLY cleanup when the longest clip finishes
                        if (longestClip && e.action.getClip() !== longestClip) return;

                        console.log('ðŸ Emote animation finished (longest clip) - cleaning up');

                        // Check if THIS is still the active emote (user might have clicked another one)
                        if (window.activeEmoteScene === emoteScene) {
                            window.activeEmoteMixer = null;
                            window.activeEmoteScene = null;
                            stadiumScene.remove(emoteScene);
                            playerMesh.visible = true;

                            // Resume idle animation
                            if (playerMesh.userData.idleClips) {
                                playerMesh.userData.idleClips.forEach(clip => {
                                    stadiumMixer.clipAction(clip).reset().play();
                                });
                            }
                        }
                    };

                    emoteMixer.addEventListener('finished', onFinished);

                    // Also set a timeout as backup
                    setTimeout(() => {
                        if (window.activeEmoteMixer === emoteMixer) {
                            onFinished();
                        }
                    }, maxDuration * 1000 + 500);

                }, undefined, (err) => {
                    console.error("âŒ Failed to load emote file:", emoteUrl);
                    iziToast.error({
                        message: `Emote file missing: ${emoteUrl}`,
                        position: 'topRight',
                        timeout: 5000
                    });
                });
            }
        }

        function restoreIdle() {
            // Deprecated in favor of swap logic callback
        }

        // --- WALLET & OTHER UI ---
        // Legacy wallet listeners removed (fixed crash)

        // document.getElementById('uploadEmoteBtn').addEventListener('click', () => document.getElementById('customEmoteInput').click());

        // --- START GAME ---
        document.getElementById('startGameBtn').addEventListener('click', async () => {
            // Only squad leader (squadId === myKey) can start the race
            if (mySquadId !== myKey) {
                iziToast.warning({
                    title: 'NOT LEADER',
                    message: 'Only the squad leader can start the race!',
                    position: 'topCenter'
                });
                return;
            }

            // Get all squad members and SORT to ensure consistent lane indexing across clients
            const squadMembers = Object.keys(onlinePlayers).filter(key =>
                onlinePlayers[key].squadId === mySquadId
            ).sort();

            console.log('Starting race for squad:', squadMembers);

            // Send race start signal to Firebase
            try {
                await setDoc(doc(db, "race_signals", mySquadId), {
                    action: 'start',
                    timestamp: Date.now(),
                    players: squadMembers,
                    leader: myKey
                });

                iziToast.success({
                    title: 'RACE STARTING',
                    message: 'Launching race for all squad members...',
                    position: 'topCenter'
                });
            } catch (e) {
                console.error('Failed to send race signal:', e);
            }
        });

        // --- RED LIGHT GREEN LIGHT LOGIC ---
        function startGreenLight() {
            if (window.raceOver) return;
            redLightActive = false;
            console.log("ðŸŸ¢ GREEN LIGHT");

            // Visuals
            const overlay = document.getElementById('gameBorderOverlay');
            if (overlay) {
                overlay.className = 'border-green';
            }

            // Audio
            const song = document.getElementById('gameSong');
            if (song) {
                song.currentTime = 0;
                song.play().catch(e => console.log("Audio play failed", e));
            }

            // Animation
            if (trackAction) {
                trackAction.reset();
                trackAction.play();
                if (trackMixer) trackMixer.timeScale = 1; // Ensure normal speed
            }

            // Schedule Red Light after 5 seconds
            if (safeTimeout) clearTimeout(safeTimeout);
            safeTimeout = setTimeout(() => {
                startRedLight();
            }, 5000);
        }

        function startRedLight() {
            if (window.raceOver) return;
            redLightActive = true;
            console.log("ðŸ”´ RED LIGHT");

            // Visuals
            const overlay = document.getElementById('gameBorderOverlay');
            if (overlay) {
                overlay.className = 'border-red';
            }

            // Audio Stop
            const song = document.getElementById('gameSong');
            if (song) {
                song.pause();
                song.currentTime = 0;
            }

            // Animation Stop
            if (trackAction) {
                trackAction.stop(); // Stop animation
            }

            // Random Duration (3-7s)
            const duration = Math.random() * 4000 + 3000;

            if (dangerTimeout) clearTimeout(dangerTimeout);
            dangerTimeout = setTimeout(() => {
                startGreenLight();
            }, duration);
        }

        function triggerDamage() {
            if (damageCooldown || window.raceOver) return;
            damageCooldown = true;
            gameHealth--;

            console.log("ðŸ’” DAMAGE! Health:", gameHealth);

            // Update Hearts
            const heart = document.getElementById(`heart${gameHealth + 1}`);
            if (heart) heart.classList.add('broken');

            // Darken Screen Effect
            const overlay = document.getElementById('gameBorderOverlay');
            if (overlay) {
                overlay.classList.add('damage-overlay');
                setTimeout(() => overlay.classList.remove('damage-overlay'), 500); // Flash dark
            }

            iziToast.error({
                title: 'DON\'T MOVE!',
                message: 'You moved during Red Light!',
                position: 'center'
            });

            if (gameHealth <= 0) {
                // Optional: Game Over Logic
                iziToast.error({
                    title: 'CRITICAL',
                    message: 'You are badly hurt! Be careful!',
                    timeout: 5000
                });
            }

            setTimeout(() => {
                damageCooldown = false;
            }, 1000);
        }

        function startRaceForPlayer(laneIndex) {
            // Show Loader with Percentage Style
            const loaderEl = document.getElementById('lobbyLoader');
            const loaderText = document.getElementById('lobbyLoadingText');

            // Force reset styles to ensure visibility
            loaderEl.style.display = 'flex';
            loaderEl.style.visibility = 'visible';
            loaderEl.style.zIndex = '9999';
            loaderEl.style.opacity = '1';

            // Hide Lobby UI Overlays (keep canvas visible)
            document.querySelectorAll('.lobby-overlay').forEach(el => el.style.display = 'none');

            // Initial Text
            if (loaderText) loaderText.innerHTML = "LOADING RACE TRACK<br>0%";

            // Load Race Track
            window.raceActive = true;
            window.raceOver = false;

            // Set flag in DB for penalty protection
            if (db && myKey) {
                updateDoc(doc(db, "all_users", myKey), { lastRaceActive: true }).catch(e => console.log(e));
            }

            const loader = new GLTFLoader();
            loader.load('assets/final_track.glb', (gltf) => {
                const trackModel = gltf.scene;

                // INIT TRACK ANIMATION
                if (gltf.animations && gltf.animations.length > 0) {
                    trackMixer = new THREE.AnimationMixer(trackModel);
                    trackAction = trackMixer.clipAction(gltf.animations[0]);
                    trackAction.loop = THREE.LoopOnce;
                    // Actually, user said 'ramdom in max 5 to 7s'. The animation length might differ.
                    // We will control play/stop manually, so LoopRepeat is fine or LoopOnce depending on the anim.
                    // Let's assume LoopRepeat for now if it's a cyclic thing, or LoopOnce if it's a specific sequence.
                    // User said "not repeat in loop just only run ramdom".
                    // So when we play, we play. When we stop, we stop.
                    trackAction.loop = THREE.LoopRepeat;
                    trackAction.clampWhenFinished = false;
                }

                // Post-load: Search for finish line object
                window.finishLineZ = 65; // User confirmed they are at 70, so 65 is safer
                console.log("ðŸ” Scanning track for finish line objects...");
                trackModel.traverse(c => {
                    if (c.isMesh) {
                        // Log names to help user find the correct object if needed
                        if (c.name.toLowerCase().includes('finish') ||
                            c.name.toLowerCase().includes('carpet') ||
                            c.name.toLowerCase().includes('end')) {

                            const worldPos = new THREE.Vector3();
                            c.getWorldPosition(worldPos);
                            window.finishLineZ = worldPos.z - 2; // Trigger slightly before the mesh
                            console.log(`ðŸ DETECTED: ${c.name} at World Z: ${worldPos.z.toFixed(2)}. Setting threshold to: ${window.finishLineZ}`);
                        }
                    }
                });

                // Position Track at origin
                trackModel.position.set(0, 0, 0);
                trackModel.traverse(c => {
                    if (c.isMesh) {
                        c.receiveShadow = true;
                        c.castShadow = true;
                    }
                });

                // Remove Lobby Model if exists
                if (window.lobbyModel) {
                    stadiumScene.remove(window.lobbyModel);
                }

                // Remove squad members from lobby
                Object.keys(squadMeshes).forEach(key => {
                    stadiumScene.remove(squadMeshes[key].scene);
                });

                // Add Track to Scene
                stadiumScene.add(trackModel);
                window.trackModel = trackModel;

                if (playerMesh) {
                    // Lane assignment based on squad position
                    const laneOffsets = [-15.4, -5.3, 6.6, 16.6];
                    const xPos = laneOffsets[laneIndex % 4];

                    console.log(`Spawned on Lane ${laneIndex + 1} at X=${xPos}`);

                    // Remove the Ideal Model, Load the Character Model for Race
                    stadiumScene.remove(playerMesh);

                    const charLoader = new GLTFLoader();
                    charLoader.load(selectedModelPath, (raceGltf) => {
                        playerMesh = raceGltf.scene;
                        playerMesh.position.set(xPos, 0, -73);
                        playerMesh.rotation.y = 0;
                        playerMesh.scale.set(1.5, 1.5, 1.5);
                        playerMesh.traverse(c => { if (c.isMesh) c.castShadow = true; });
                        stadiumScene.add(playerMesh);

                        stadiumMixer = new THREE.AnimationMixer(playerMesh);

                        // Helper to remove tracks that don't match any node in the model
                        const sanitizeAnimationClips = (clips, rootMesh) => {
                            if (!clips) return [];
                            const validClips = [];
                            let totalRemoved = 0;

                            clips.forEach(clip => {
                                const validTracks = [];
                                clip.tracks.forEach(track => {
                                    // Track name format: "NodeName.propertyName" (e.g. "Hips.position")
                                    // We need to check if "NodeName" exists in the hierarchy
                                    // Some regex to extract the node name part safely handling special chars if any
                                    let nodeName = track.name.split('.')[0];

                                    // Special handling: sometimes regex chars in name
                                    // But simple split by first dot is usually safe for GLTF

                                    // Three.js PropertyBinding.parseTrackName is better but internal.
                                    // Let's rely on simple split or just check rootMesh.getObjectByName

                                    // Sanity check: find node
                                    // Note: getObjectByName is recursive.
                                    const node = rootMesh.getObjectByName(nodeName);

                                    // If node exists, keep track. 
                                    // SPECIAL CASE: morphTargetInfluences/quaternion/etc on the root mesh itself might have empty node name or specific naming?
                                    // Usually GLTF imports have named nodes.

                                    if (node || nodeName === "" || nodeName === rootMesh.name) {
                                        validTracks.push(track);
                                    } else {
                                        // Fuzzy match attempt (remove blender .001 suffixes)
                                        // This handles cases where user's stand1.glb has Cube.001 but loading model has Cube
                                        const fuzzyName = nodeName.replace(/\.\d+$/, '');
                                        const fuzzyNode = rootMesh.getObjectByName(fuzzyName);

                                        if (fuzzyNode) {
                                            // Found a match! We MUST retarget the track to the correct node name
                                            console.log(`ðŸ§© Retargeting track: ${nodeName} -> ${fuzzyNode.name}`);

                                            // Clone track but change name
                                            const newTrackName = fuzzyNode.name + '.' + track.name.split('.').slice(1).join('.');

                                            // We need to create a new track of same type
                                            // Three.js tracks are TypedKeyframeTrack usually
                                            const newTrack = track.clone();
                                            newTrack.name = newTrackName;
                                            validTracks.push(newTrack);
                                        } else {
                                            // Track is truly garbage (Cube, Light, Camera, etc from Blender scene)
                                            totalRemoved++;
                                        }
                                    }
                                });

                                if (validTracks.length > 0) {
                                    // Create new clip with valid tracks
                                    const newClip = clip.clone();
                                    newClip.tracks = validTracks;
                                    validClips.push(newClip);
                                } else {
                                    console.warn(`âš ï¸ Clip ${clip.name} removed - 0 valid tracks`);
                                }
                            });

                            if (totalRemoved > 0) {
                                console.log(`ðŸ§¹ Sanitized animations: Removed ${totalRemoved} invalid tracks.`);
                            }
                            return validClips;
                        };

                        // Extract character number from selectedModelPath (e.g., character1.glb -> 1)
                        const charMatch = selectedModelPath.match(/character(\d+)\.glb/);
                        const charNum = charMatch ? charMatch[1] : "1";

                        // Initialize animation state
                        playerMesh.userData.animations = {
                            idle: null,
                            run: null,
                            currentState: 'idle'
                        };

                        let idleLoaded = false;
                        let runLoaded = false;

                        // Load ideal animation (idealN.glb)
                        const idleAnimLoader = new GLTFLoader();
                        idleAnimLoader.load(`assets/ideal${charNum}.glb`, (idleGltf) => {
                            console.log(`âœ… Loaded ideal${charNum}.glb animation for race`);

                            if (idleGltf.animations && idleGltf.animations.length > 0) {
                                // SANITIZE
                                playerMesh.userData.animations.idle = sanitizeAnimationClips(idleGltf.animations, playerMesh);
                                idleLoaded = true;

                                // Start with idle animation
                                idleGltf.animations.forEach((clip) => {
                                    const action = stadiumMixer.clipAction(clip);
                                    action.play();
                                    console.log(`Playing idle animation: ${clip.name}`);
                                });
                                playerMesh.userData.animations.currentState = 'idle';
                            }
                        }, undefined, (err) => {
                            console.error(`Failed to load ideal${charNum}.glb:`, err);
                        });

                        // Load run animation (runN.glb)
                        const runAnimLoader = new GLTFLoader();
                        runAnimLoader.load(`assets/run${charNum}.glb`, (runGltf) => {
                            console.log(`âœ… Loaded run${charNum}.glb animation for race`);

                            if (runGltf.animations && runGltf.animations.length > 0) {
                                // SANITIZE
                                playerMesh.userData.animations.run = sanitizeAnimationClips(runGltf.animations, playerMesh);
                                runLoaded = true;
                                console.log(`Stored ${runGltf.animations.length} run animations`);
                            }
                        }, undefined, (err) => {
                            console.warn(`Failed to load run${charNum}.glb, trying run1.glb as fallback...`);

                            // Try run1.glb as fallback
                            const fallbackLoader = new GLTFLoader();
                            fallbackLoader.load('assets/run1.glb', (runGltf) => {
                                console.log(`âœ… Loaded run1.glb as fallback animation`);

                                if (runGltf.animations && runGltf.animations.length > 0) {
                                    playerMesh.userData.animations.run = runGltf.animations;
                                    runLoaded = true;
                                }
                            }, undefined, (err2) => {
                                console.error('Failed to load run1.glb fallback:', err2);
                                // Last resort: use character's own animations
                                const runClip = raceGltf.animations.find(a => a.name.toLowerCase().includes('run')) || raceGltf.animations[0];
                                if (runClip) {
                                    playerMesh.userData.animations.run = [runClip];
                                }
                            });
                        });

                        // Load STAND animation (stand1.glb) for POST-MOVEMENT idle
                        const standAnimLoader = new GLTFLoader();
                        // Loading stand1.glb specifically as requested
                        standAnimLoader.load('assets/stand1.glb', (standGltf) => {
                            console.log(`âœ… Loaded stand1.glb animation for race stop`);
                            if (standGltf.animations && standGltf.animations.length > 0) {
                                // SANITIZE: Remove garbage tracks (Cube, Sphere, etc)
                                playerMesh.userData.animations.stand = sanitizeAnimationClips(standGltf.animations, playerMesh);
                                console.log(`âœ… Stand animations sanitized. Count: ${playerMesh.userData.animations.stand.length}`);
                            }
                        }, undefined, (err) => {
                            console.warn("Failed to load stand1.glb - will fallback to idle", err);
                            // Start: fallback to existing idle to prevent freezing if missing
                            // We don't set 'stand' property, so logic will just use 'idle' if 'stand' is null? 
                            // No, we need to handle that in the loop.
                        });

                        // Initialize movement state flag
                        playerMesh.userData.hasMoved = false;

                        // Reset camera angles
                        window.cameraAngleH = Math.PI;
                        window.cameraAngleV = 0.5;
                        window.raceMode = true;
                    });
                }

                console.log('ðŸ Track Loaded & Player Positioned');

                // Spawn OTHER squad members on THEIR lanes in the race track
                Object.keys(onlinePlayers).forEach(key => {
                    if (onlinePlayers[key].squadId === mySquadId && key !== myKey) {
                        const members = Object.keys(onlinePlayers).filter(k => onlinePlayers[k].squadId === mySquadId).sort();
                        const theirLane = members.indexOf(key);
                        spawnSquadMember(key, onlinePlayers[key].model, theirLane);
                    }
                });

                // Done Loading - Hide Loader
                gsap.to(loaderEl, {
                    opacity: 0,
                    duration: 0.5,
                    delay: 0.5,
                    onComplete: () => {
                        loaderEl.style.display = 'none';
                        document.getElementById('gameUI').style.display = 'block';

                        // Start Red Light Green Light Logic
                        document.getElementById('healthDisplay').style.display = 'flex';
                        startGreenLight();

                        // Create/Show Debug Coordinate
                        let debugEl = document.getElementById('debugCoord');
                        if (!debugEl) {
                            debugEl = document.createElement('div');
                            debugEl.id = 'debugCoord';
                            debugEl.style.position = 'absolute';
                            debugEl.style.top = '10px';
                            debugEl.style.left = '50%';
                            debugEl.style.transform = 'translateX(-50%)';
                            debugEl.style.color = 'yellow';
                            debugEl.style.fontFamily = 'monospace';
                            debugEl.style.fontSize = '14px';
                            debugEl.style.zIndex = '9999';
                            document.body.appendChild(debugEl);
                        }

                        // --- ANIMATION DEBUG OVERLAY (Added for troubleshooting) ---
                        let animDebugEl = document.getElementById('animDebug');
                        if (!animDebugEl) {
                            animDebugEl = document.createElement('div');
                            animDebugEl.id = 'animDebug';
                            animDebugEl.style.position = 'absolute';
                            animDebugEl.style.top = '50px';
                            animDebugEl.style.left = '10px';
                            animDebugEl.style.color = '#0f6';
                            animDebugEl.style.background = 'rgba(0,0,0,0.7)';
                            animDebugEl.style.padding = '5px';
                            animDebugEl.style.fontFamily = 'monospace';
                            animDebugEl.style.fontSize = '12px';
                            animDebugEl.style.zIndex = '9999';
                            animDebugEl.style.pointerEvents = 'none';
                            document.body.appendChild(animDebugEl);
                        }

                        if (debugEl) {
                            debugEl.style.fontSize = '20px';
                            debugEl.style.fontWeight = 'bold';
                            debugEl.style.textShadow = '1px 1px 2px black';
                            debugEl.style.pointerEvents = 'none';
                            debugEl.style.zIndex = '10000';
                            debugEl.style.display = 'block';
                        }

                        // Init Nipple Joystick
                        if (!window.nippleManager) {
                            window.nippleManager = nipplejs.create({
                                zone: document.getElementById('joystick'),
                                mode: 'static',
                                position: { left: '80px', bottom: '80px' },
                                color: 'white'
                            });

                            // Joystick movement handling
                            window.joystickData = { active: false, vector: { x: 0, y: 0 } };

                            window.nippleManager.on('move', (evt, data) => {
                                window.joystickData.active = true;
                                const angle = data.angle.radian;
                                const force = Math.min(data.force, 2) / 2; // Normalize 0-1
                                window.joystickData.vector.x = Math.cos(angle) * force;
                                window.joystickData.vector.y = Math.sin(angle) * force;
                            });

                            window.nippleManager.on('end', () => {
                                window.joystickData.active = false;
                                window.joystickData.vector.x = 0;
                                window.joystickData.vector.y = 0;
                            });
                        }

                        // Hide boost button (not needed for now)
                        const boostBtn = document.getElementById('pushBtn');
                        if (boostBtn) boostBtn.style.display = 'none';

                        if (db && myKey) {
                            updateDoc(doc(db, "all_users", myKey), {
                                matches: increment(1)
                            }).catch(e => console.error("Stats Error:", e));
                        }
                    } // End onComplete
                }); // End gsap.to
            }, (xhr) => {
                // Progress
                if (loaderText && xhr.total > 0) {
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                    loaderText.style.textAlign = 'center';
                    loaderText.style.width = '100%';
                    loaderText.innerHTML = `LOADING RACE TRACK<br>${percent}%`;
                }
            }, (err) => {
                console.error("Track Load Error:", err);
                if (loaderText) loaderText.innerHTML = "TRACK LOAD FAILED";
                iziToast.error({ message: "Failed to load final_track.glb" });
            });
        }

        // Loop (Clock is initialized in setupStadiumThreeJS)
        // const clock = new THREE.Clock(); // Already declared globally

        // Keyboard state tracking
        const keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };

        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
        });

        function animate() {
            requestAnimationFrame(animate);
            // Guards: only render if Three.js is initialized
            if (!renderer || !camera || !stadiumScene || !clock) return;

            const dt = clock.getDelta();
            if (stadiumMixer) stadiumMixer.update(dt);
            if (window.activeEmoteMixer) window.activeEmoteMixer.update(dt);
            if (trackMixer) trackMixer.update(dt);
            if (window.activeEmoteMixer) window.activeEmoteMixer.update(dt);

            // Player Movement Logic (only in race mode)
            if (window.raceMode && playerMesh) {
                const moveSpeed = 0.5; // Units per frame (Increased from 0.1)
                let moveX = 0;
                let moveZ = 0;
                let movementMagnitude = 0; // Track how much we're moving

                // Joystick movement
                if (window.joystickData && window.joystickData.active) {
                    // Joystick X is left/right, Y is forward/backward
                    moveX = window.joystickData.vector.x * moveSpeed;
                    moveZ = -window.joystickData.vector.y * moveSpeed; // Invert Y for forward = positive
                }

                // Keyboard movement (WASD + Arrow Keys)
                if (keys.w || keys.ArrowUp) moveZ += moveSpeed;
                if (keys.s || keys.ArrowDown) moveZ -= moveSpeed;
                if (keys.a || keys.ArrowLeft) moveX += moveSpeed;
                if (keys.d || keys.ArrowRight) moveX -= moveSpeed;

                // Calculate movement magnitude for animation speed
                movementMagnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);

                // --- ANIMATION STATE SWITCHING ---
                if (playerMesh.userData.animations && stadiumMixer) {
                    const isMoving = movementMagnitude > 0.01;

                    // Update 'hasMoved' state once they move for the first time
                    if (isMoving && !playerMesh.userData.hasMoved) {
                        playerMesh.userData.hasMoved = true;
                    }

                    // Determine target state
                    let targetState = 'idle';
                    if (isMoving) {
                        targetState = 'run';
                    } else if (playerMesh.userData.hasMoved && playerMesh.userData.animations.stand && playerMesh.userData.animations.stand.length > 0) {
                        // If we have moved before, and we are now stopped, AND we have a VALID stand animation -> STAND
                        targetState = 'stand';
                    } else {
                        // Otherwise (haven't moved yet OR missing/empty stand animation) -> IDLE (Lobby Ideal)
                        targetState = 'idle';
                    }

                    // Switch animation if state changed
                    if (playerMesh.userData.animations.currentState !== targetState) {
                        console.log(`ðŸŽ¬ Switching animation from ${playerMesh.userData.animations.currentState} to ${targetState}`);

                        // Stop all current animations
                        stadiumMixer.stopAllAction();

                        // Play new animation
                        const clips = playerMesh.userData.animations[targetState];
                        if (clips && clips.length > 0) {
                            clips.forEach((clip) => {
                                const action = stadiumMixer.clipAction(clip);
                                action.reset();
                                action.play();
                            });
                        } else {
                            console.warn(`âš ï¸ Target state '${targetState}' has NO CLIPS! Character may freeze.`);
                        }

                        playerMesh.userData.animations.currentState = targetState;
                    }

                    // UPDATE DEBUG OVERLAY
                    const debugDiv = document.getElementById('animDebug');
                    if (debugDiv) {
                        const standClips = playerMesh.userData.animations.stand ? playerMesh.userData.animations.stand.length : 0;
                        debugDiv.innerHTML = `
                            STATE: ${targetState.toUpperCase()}<br>
                            MAG: ${movementMagnitude.toFixed(4)}<br>
                            HAS_MOVED: ${playerMesh.userData.hasMoved}<br>
                            STAND_CLIPS: ${standClips}<br>
                            IS_MOVING: ${isMoving}
                        `;
                    }

                    // Adjust animation speed based on movement magnitude
                    if (isMoving && playerMesh.userData.animations.run) {
                        // Normalize movement magnitude (0.5 is max moveSpeed)
                        const speedFactor = Math.min(movementMagnitude / moveSpeed, 1.0);
                        // Map to animation speed: 0.3 (slow walk) to 1.5 (fast run)
                        const animSpeed = 0.3 + (speedFactor * 1.2);

                        playerMesh.userData.animations.run.forEach((clip) => {
                            const action = stadiumMixer.clipAction(clip);
                            action.setEffectiveTimeScale(animSpeed);
                        });
                    }
                }

                // Apply movement
                if (moveX !== 0 || moveZ !== 0) {
                    // Check Red Light Penalty
                    if (redLightActive && !window.raceOver) {
                        triggerDamage();
                    }

                    playerMesh.position.x += moveX;
                    playerMesh.position.z += moveZ;

                    // --- FINISH LINE DETECTION ---
                    const thresh = 70; // Striktly 70 as per user request
                    if (playerMesh.position.z >= thresh && !window.raceOver) {
                        console.log(`ðŸ FINISH TRIGGERED! Z: ${playerMesh.position.z.toFixed(2)} >= ${thresh}`);
                        window.raceOver = true;
                        handleVictory();
                    }
                }
            }

            // Sync other squad members in race
            if (window.raceMode) {
                Object.keys(squadMeshes).forEach(key => {
                    const data = onlinePlayers[key];
                    if (data && data.pos) {
                        const mesh = squadMeshes[key].scene;
                        // Interpolate movement for smoothness
                        mesh.position.lerp(new THREE.Vector3(data.pos.x, data.pos.y, data.pos.z), 0.1);
                        if (data.rotY !== undefined) {
                            // Lerp rotation
                            const targetQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, data.rotY, 0));
                            mesh.quaternion.slerp(targetQuat, 0.1);
                        }

                        // Update mixer for remote players
                        if (squadMeshes[key].mixer) squadMeshes[key].mixer.update(dt);
                    }
                });
            }

            // Camera Follow Logic for Race
            if (window.raceMode && playerMesh) {
                // Calculate Camera Position based on angle
                const distH = 10; // Horizontal distance to player

                // Spherical Coordinates
                // cameraAngleH = Yaw (around Y axis)
                // cameraAngleV = Pitch (Height angle)

                // Ensure defaults
                if (window.cameraAngleH === undefined) window.cameraAngleH = Math.PI;
                if (window.cameraAngleV === undefined) window.cameraAngleV = 0.5; // ~30 degrees


                // Calculate offsets
                // Y (Up) = dist * sin(V)
                // H_Radius = dist * cos(V)
                // X = H_Radius * sin(H)
                // Z = H_Radius * cos(H)

                const radius = 12; // Total distance from player center

                const yOffset = radius * Math.sin(window.cameraAngleV);
                const hRadius = radius * Math.cos(window.cameraAngleV);

                const xOffset = hRadius * Math.sin(window.cameraAngleH);
                const zOffset = hRadius * Math.cos(window.cameraAngleH);

                camera.position.x = playerMesh.position.x + xOffset;
                camera.position.y = playerMesh.position.y + yOffset;
                camera.position.z = playerMesh.position.z + zOffset;

                camera.lookAt(playerMesh.position.x, playerMesh.position.y + 2, playerMesh.position.z);

                const dEl = document.getElementById('debugCoord');
                if (dEl) {
                    dEl.innerHTML = `X: ${playerMesh.position.x.toFixed(2)} | Z: ${playerMesh.position.z.toFixed(2)}<br>
                                    H: ${window.cameraAngleH.toFixed(2)} | V: ${window.cameraAngleV.toFixed(2)}`;
                }
            }

            renderer.render(stadiumScene, camera);
        }


        // --- Camera Rotation Logic (Robust Multi-touch & Spherical) ---
        // Defaults
        window.cameraAngleH = Math.PI; // Horizontal (Yaw)
        window.cameraAngleV = 0.5;     // Vertical (Pitch)

        let isLeftMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let activeTouchId = null;

        function updateCameraRotation(deltaX, deltaY) {
            const sensitivity = 0.005;

            // Horizontal (Yaw)
            // Left Drag (negative deltaX) should move CAMERA Left (rotate CW around player?)
            // If I drag left, I expect to see what's on the right.
            // Drag Left -> DeltaX < 0.
            // If Angle decreases, Camera moves CW (from +Z to +X).
            window.cameraAngleH -= deltaX * sensitivity;

            // Vertical (Pitch)
            // Drag Up (negative deltaY). Expect Camera to go Up (Pitch Increase) or Down?
            // Usually Drag Up -> Look Down (Camera goes Up).
            // Drag Up -> DeltaY < 0.
            // So we subtract or add?
            // If DeltaY < 0, we want Angle to Increase (go up).
            // So: -= DeltaY
            window.cameraAngleV -= deltaY * sensitivity;

            // Clamp Vertical
            const minV = 0.1; // Low angle
            const maxV = 1.4; // High angle
            window.cameraAngleV = Math.max(minV, Math.min(maxV, window.cameraAngleV));
        }

        // Toggle Orientation Key
        window.addEventListener('keydown', (e) => {
            if (e.key && e.key.toLowerCase() === 'r' && playerMesh) {
                playerMesh.rotation.y += Math.PI;
                console.log("Flipped Player Rotation");
            }
        });

        // Mouse Events (Capture Phase)
        // Mouse Events (Capture Phase)
        // DEBUG: Force Flash on ANY click to prove events work
        window.addEventListener('mousedown', () => {
            const dEl = document.getElementById('debugCoord');
            if (dEl) dEl.style.color = 'red';
            setTimeout(() => { if (dEl) dEl.style.color = 'yellow'; }, 100);
        }, { capture: true });

        window.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // Only Left Click
            if (e.target.closest('#joystick') || e.target.closest('button') || e.target.closest('input')) return;

            e.preventDefault(); // Prevent text selection / native drag

            isLeftMouseDown = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }, { capture: true });

        window.addEventListener('mouseup', () => { isLeftMouseDown = false; }, { capture: true });

        window.addEventListener('mousemove', (e) => {
            if (!isLeftMouseDown) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            updateCameraRotation(deltaX, deltaY);
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }, { capture: true });

        // Touch Events (Capture Phase)
        window.addEventListener('touchstart', (e) => {
            // Find a touch that is NOT on UI
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (!t.target.closest('#joystick') && !t.target.closest('button') && !t.target.closest('input')) {
                    activeTouchId = t.identifier;
                    previousMousePosition = { x: t.clientX, y: t.clientY };
                    break;
                }
            }
        }, { capture: true, passive: false });

        window.addEventListener('touchend', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === activeTouchId) activeTouchId = null;
            }
        }, { capture: true });

        window.addEventListener('touchmove', (e) => {
            if (activeTouchId === null) return;
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === activeTouchId) {
                    // Prevent Default Scroll
                    if (e.cancelable) e.preventDefault();

                    const deltaX = t.clientX - previousMousePosition.x;
                    const deltaY = t.clientY - previousMousePosition.y;
                    updateCameraRotation(deltaX, deltaY);
                    previousMousePosition = { x: t.clientX, y: t.clientY };
                    break;
                }
            }
        }, { capture: true, passive: false });
        document.getElementById('addFriendSubmit').addEventListener('click', async () => {
            const input = document.getElementById('addFriendInput');
            const friendName = input.value.trim();

            if (!friendName) {
                iziToast.warning({
                    title: 'EMPTY',
                    message: 'Enter a username',
                    position: 'topCenter'
                });
                return;
            }

            if (friendName.toLowerCase() === myUsername.toLowerCase()) {
                iziToast.error({
                    title: 'BRO?',
                    message: 'You cannot add yourself',
                    position: 'topCenter'
                });
                return;
            }

            try {
                const friendKey = friendName.replace(/[.#$/[\]]/g, "_").toLowerCase();

                // Check if user exists
                const userSnap = await getDoc(doc(db, "all_users", friendKey));
                if (!userSnap.exists()) {
                    iziToast.error({
                        title: 'NOT FOUND',
                        message: 'User does not exist',
                        position: 'topCenter'
                    });
                    return;
                }

                // Send request
                await addDoc(collection(db, "friend_requests"), {
                    from: myKey,
                    fromName: myUsername,
                    to: friendKey,
                    status: 'pending',
                    timestamp: Date.now()
                });

                iziToast.success({
                    title: 'SENT',
                    message: `Friend request sent to ${friendName}`,
                    position: 'topRight'
                });

                input.value = '';

            } catch (err) {
                console.error(err);
                iziToast.error({
                    title: 'ERROR',
                    message: 'Failed to send request',
                    position: 'topCenter'
                });
            }
        });
        const afInput = document.getElementById('addFriendInput');
        if (afInput) {
            afInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    const afSubmit = document.getElementById('addFriendSubmit');
                    if (afSubmit) afSubmit.click();
                }
            });
        }
        ['playerSearchInput', 'addFriendInput'].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;

            el.addEventListener('click', e => {
                e.stopPropagation();
                el.focus();
            });
        });

        // ========== SQUAD MANAGEMENT SYSTEM ==========

        // Update Squad Members Panel UI
        function updateSquadPanel() {
            const panel = document.getElementById('squadPanel');
            const membersList = document.getElementById('squadMembersList');
            if (!panel || !membersList) return;
            const squadMembers = Object.keys(onlinePlayers).filter(key => onlinePlayers[key].squadId === mySquadId);
            if (squadMembers.length > 1) {
                panel.style.display = 'block';
                membersList.innerHTML = '';
                squadMembers.forEach(key => {
                    const member = onlinePlayers[key];
                    const isLeader = key === mySquadId;
                    const isMe = key === myKey;
                    const isReady = member.isReady;

                    const div = document.createElement('div');
                    div.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:8px;background:rgba(255,255,255,0.05);margin-bottom:5px;border-radius:5px;';

                    let html = `
                            <div style="display:flex; align-items:center;">
                                <span style="color:#fff;">${member.name}</span>
                                ${isLeader ? `<span style="color:#ffd700;font-size:0.8rem;margin-left:5px;">ðŸ‘‘</span>` : ''}
                                ${isMe ? `<span style="color:#00d4ff;font-size:0.8rem;margin-left:5px;">(You)</span>` : ''}
                            </div>
                            <div style="display:flex; align-items:center;">
                                ${!isLeader ? `<span style="margin-right:10px; font-size:0.8rem; color:${isReady ? '#0f6' : '#f00'};">${isReady ? 'READY' : 'NOT READY'}</span>` : ''}
                        `;
                    div.innerHTML = html;

                    if (mySquadId === myKey && !isMe) {
                        const kickBtn = document.createElement('button');
                        kickBtn.innerHTML = 'âŒ';
                        kickBtn.style.cssText = 'background:rgba(255,0,0,0.2);border:1px solid red;color:red;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:0.9rem;';
                        kickBtn.onclick = () => kickPlayer(key, member.name);
                        div.appendChild(kickBtn);
                    }
                    membersList.appendChild(div);
                });
            } else { panel.style.display = 'none'; }
            const leaveBtn = document.getElementById('leaveSquadBtn');
            if (leaveBtn) leaveBtn.style.display = (squadMembers.length > 1 && mySquadId !== myKey) ? 'inline-block' : 'none';
        }

        function updateStartButtonState() {
            const startBtn = document.getElementById('startGameBtn');
            if (!startBtn) return;
            const isLeader = mySquadId === myKey;

            // Member screen should NOT have start game button
            startBtn.style.display = isLeader ? 'inline-block' : 'none';

            if (isLeader) {
                // Logic for enabling/disabling moved to updateReadyButtonUI for consistency
            }
        }

        async function leaveSquad() {
            if (!db || !myKey) return;
            try {
                await updateDoc(doc(db, "players", myKey), { squadId: myKey });
                mySquadId = myKey;
                iziToast.success({ title: 'LEFT SQUAD', message: 'You are now in your own lobby', position: 'topCenter' });
                updateSquadPanel();
                updateStartButtonState();
            } catch (e) {
                console.error('Failed to leave squad:', e);
                iziToast.error({ message: 'Failed to leave squad' });
            }
        }

        async function kickPlayer(targetKey, targetName) {
            if (!db || mySquadId !== myKey) return;
            try {
                await updateDoc(doc(db, "players", targetKey), { squadId: targetKey });
                iziToast.info({ title: 'PLAYER KICKED', message: `${targetName} was removed from the squad`, position: 'topCenter' });
            } catch (e) {
                console.error('Failed to kick player:', e);
                iziToast.error({ message: 'Failed to kick player' });
            }
        }

        // --- NEW READY & SYNC SYSTEM ---

        async function toggleReady() {
            if (!db || !myKey) return;
            const isCurrentlyReady = onlinePlayers[myKey]?.isReady || false;
            try {
                await updateDoc(doc(db, "players", myKey), { isReady: !isCurrentlyReady });
                iziToast.show({
                    title: !isCurrentlyReady ? 'READY' : 'UNREADY',
                    message: !isCurrentlyReady ? 'Waiting for leader...' : 'Status updated',
                    position: 'topCenter',
                    color: !isCurrentlyReady ? 'green' : 'yellow'
                });
            } catch (e) {
                console.error('Ready Toggle Error:', e);
            }
        }

        function updateReadyButtonUI() {
            const readyBtn = document.getElementById('readyBtn');
            if (!readyBtn) return;

            const isMember = mySquadId !== myKey;
            readyBtn.style.display = isMember ? 'inline-block' : 'none';

            if (isMember) {
                const isReady = onlinePlayers[myKey]?.isReady || false;
                if (isReady) {
                    readyBtn.innerText = 'UNREADY';
                    readyBtn.classList.add('active');
                } else {
                    readyBtn.innerText = 'READY';
                    readyBtn.classList.remove('active');
                }
            }

            // Leader validation: only start if all members are ready
            if (mySquadId === myKey) {
                const startBtn = document.getElementById('startGameBtn');
                if (!startBtn) return;

                const squadMembers = Object.keys(onlinePlayers).filter(k => onlinePlayers[k].squadId === myKey && k !== myKey);
                const allReady = squadMembers.every(k => onlinePlayers[k].isReady === true);

                if (squadMembers.length > 0 && !allReady) {
                    startBtn.disabled = true;
                    startBtn.style.opacity = '0.5';
                    startBtn.innerText = "WAITING FOR TEAM...";
                    startBtn.classList.remove('btn-primary');
                    startBtn.classList.add('btn-secondary');
                } else {
                    startBtn.disabled = false;
                    startBtn.style.opacity = '1';
                    startBtn.innerText = "START RACE";
                    startBtn.classList.add('btn-primary');
                    startBtn.classList.remove('btn-secondary');
                }
            }
        }

        let lastPosSync = 0;
        function syncPositionInRace() {
            if (!window.raceMode || !playerMesh || !db || !myKey) return;

            const now = Date.now();
            if (now - lastPosSync < 100) return; // Sync every 100ms
            lastPosSync = now;

            updateDoc(doc(db, "players", myKey), {
                pos: { x: playerMesh.position.x, y: playerMesh.position.y, z: playerMesh.position.z },
                rotY: playerMesh.rotation.y
            }).catch(e => console.error("Sync Pos Error:", e));
        }

        const readyBtn = document.getElementById('readyBtn');
        if (readyBtn) readyBtn.addEventListener('click', toggleReady);

        const leaveSquadBtn = document.getElementById('leaveSquadBtn');
        if (leaveSquadBtn) leaveSquadBtn.addEventListener('click', leaveSquad);

        // --- PROFILE SYSTEM LOGIC ---
        // --- PROFILE SYSTEM LOGIC ---
        // 3D Profile REMOVED by user request
        let profileScene, profileCamera, profileRenderer, profileMixer, profileModel;
        let isProfileOpen = false;

        /*
        function initProfile3D() {
             // ... (Code Disabled)
        }

        function loadProfileModel() {
            // ... (Code Disabled)
        }

        function animateProfile() {
             // ... (Code Disabled)
        }
        */

        // Profile UI Handlers
        const profilePill = document.getElementById('profilePill');
        if (profilePill) {
            profilePill.addEventListener('click', async () => {
                if (!myKey) {
                    iziToast.warning({ message: "Signing in... please wait", position: 'topCenter' });
                    return;
                }
                isProfileOpen = true;
                const modal = document.getElementById('profileModal');
                if (modal) modal.classList.add('active');

                const nameEl = document.getElementById('modalProfName');
                if (nameEl) nameEl.innerHTML = `${(myUsername || 'AGENT').toUpperCase()}<span class="prof-badge">ELITE</span>`;

                const pillNameEl = document.getElementById('pillName');
                if (pillNameEl) pillNameEl.innerText = (myUsername || 'AGENT').toUpperCase();

                // Fetch REAL Stats
                await updateProfileStatsUI();

                // Set UID placeholder
                const uidHash = myKey.split('').reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a }, 0);
                const uidEl = document.querySelector('.prof-uid');
                if (uidEl) uidEl.innerText = `UID: ${Math.abs(uidHash)}`;

                // 3D Init Removed
                /*
                if (!profileRenderer) {
                    initProfile3D();
                } else {
                    loadProfileModel();
                }
                animateProfile();
                */
            });
        }

        const coinPill = document.getElementById('coinPill');
        if (coinPill) {
            coinPill.addEventListener('click', () => {
                const btn = document.getElementById('walletBtn');
                if (btn) btn.click();
            });
        }

        document.getElementById('closeProfileBtn').addEventListener('click', () => {
            isProfileOpen = false;
            document.getElementById('profileModal').classList.remove('active');
        });

        // Tab Switching in Profile
        document.querySelectorAll('.side-tab').forEach(tab => {
            tab.addEventListener('click', async (e) => {
                document.querySelectorAll('.side-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                const content = tab.dataset.content;
                const contentArea = document.getElementById('profileContent');

                if (content === 'overview') {
                    contentArea.innerHTML = `
                         <div class="stats-grid">
                            <div class="stat-card">
                                <span class="stat-value" id="statMatches">0</span>
                                <span class="stat-label">MATCHES</span>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value" id="statWins">0</span>
                                <span class="stat-label">WINS</span>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value" id="statWinRate">0%</span>
                                <span class="stat-label">WIN RATE</span>
                            </div>
                        </div>

                         <div class="rank-display">
                            <div class="rank-icon" id="profRankIcon">
                                <img src="ranks/bronze.png" alt="Rank">
                            </div>
                            <div class="rank-info">
                                <h3 id="profRankTitle">HEROIC III</h3>
                                <p id="profRankPoints">RANK POINTS: 0 / 3,000</p>
                            </div>
                        </div>

                        <div style="margin-top: 30px; border-top: 1px solid rgba(255,255,255,0.05); padding-top: 25px;">
                            <span style="color: #888; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 2px;">Racing Integrity</span>
                            <div style="background: rgba(255,255,255,0.02); padding: 20px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); margin-top: 15px;">
                                <div style="color: #666; font-size: 0.6rem; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 1px;">Honor Score</div>
                                <div style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; position: relative;">
                                    <div id="profHonorBar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #0f6, #00d4ff); border-radius: 3px; box-shadow: 0 0 15px rgba(0,255,100,0.4); transition: width 0.5s ease;"></div>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                                    <span id="profHonorStatus" style="color: #0f6; font-size: 0.75rem; font-weight: bold; text-transform: uppercase;">STABLE</span>
                                    <span id="profHonorValue" style="color: #fff; font-size: 0.75rem; font-weight: 800;">100/100</span>
                                </div>
                                <p style="color: #444; font-size: 0.6rem; margin: 10px 0 0 0; font-style: italic;">Penalty for leaving mid-race: -5 Honor</p>
                            </div>
                        </div>
                    `;
                    // Immediately re-fetch/display stats for this tab
                    updateProfileStatsUI();
                } else if (content === 'stats') {
                    contentArea.innerHTML = `
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div class="stat-card">
                                <span class="stat-value">15,420m</span>
                                <span class="stat-label">TOTAL DISTANCE</span>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">42.5 km/h</span>
                                <span class="stat-label">MAX SPEED</span>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">12.5k</span>
                                <span class="stat-label">TOTAL COINS</span>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">B+</span>
                                <span class="stat-label">OVERALL GRADE</span>
                            </div>
                        </div>
                    `;
                } else if (content === 'history') {
                    contentArea.innerHTML = `<div style="text-align:center; padding: 20px; color: #888;">FETCHING HISTORY...</div>`;

                    if (db && myKey) {
                        const q = query(collection(db, "match_history"), where("userId", "==", myKey));
                        const historySnap = await getDocs(q);

                        if (historySnap.empty) {
                            contentArea.innerHTML = `<div style="text-align:center; padding: 50px; color: #666; font-size: 1.2rem; display:flex; flex-direction:column; align-items:center; gap:20px;">
                                <div style="font-size: 4rem; opacity: 0.2;">ðŸ</div>
                                NO MATCHES PLAYED YET
                            </div>`;
                        } else {
                            // Sort by timestamp local
                            const docs = historySnap.docs.map(d => d.data()).sort((a, b) => (b.timestamp?.toMillis ? b.timestamp.toMillis() : 0) - (a.timestamp?.toMillis ? a.timestamp.toMillis() : 0));

                            let html = `<div style="display: flex; flex-direction: column; gap: 10px;">`;
                            docs.slice(0, 5).forEach(m => {
                                const date = m.timestamp?.toDate ? m.timestamp.toDate().toLocaleDateString() : 'Recent';
                                const color = m.result === 'WIN' ? '#0f6' : '#f44';
                                html += `
                                    <div style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); padding: 15px 25px; border-radius: 5px; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid ${color};">
                                        <div>
                                            <div style="color: ${color}; font-weight: 800; font-size: 1rem;">${m.result}</div>
                                            <div style="color: #666; font-size: 0.7rem;">${date}</div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="color: #ffd700; font-weight: bold;">+${m.coins} COINS</div>
                                            <div style="color: #888; font-size: 0.7rem;">RANK POINTS +25</div>
                                        </div>
                                    </div>
                                `;
                            });
                            html += `</div>`;
                            contentArea.innerHTML = html;
                        }
                    }
                } else {
                    contentArea.innerHTML = `<div style="text-align:center; padding: 50px; color: #666; font-size: 1.2rem; letter-spacing: 5px;">DATA LOADING...</div>`;
                }
            });
        });

        async function updateProfileStatsUI() {
            if (db && myKey) {
                try {
                    const userSnap = await getDoc(doc(db, "all_users", myKey));
                    if (userSnap.exists()) {
                        const data = userSnap.data();
                        const matches = data.matches || 0;
                        const wins = data.wins || 0;
                        const winRate = matches > 0 ? ((wins / matches) * 100).toFixed(1) : 0;

                        const elMatches = document.getElementById('statMatches');
                        const elWins = document.getElementById('statWins');
                        const elWinRate = document.getElementById('statWinRate');

                        if (elMatches) elMatches.innerText = matches;
                        if (elWins) elWins.innerText = wins;
                        if (elWinRate) elWinRate.innerText = winRate + "%";

                        // --- DYNAMIC RANK PROGRESSION ---
                        const elStanding = document.getElementById('profStanding');
                        const elStyle = document.getElementById('profStyle');
                        const elRankTitle = document.getElementById('profRankTitle');
                        const elRankPoints = document.getElementById('profRankPoints');
                        const elRankIcon = document.getElementById('profRankIcon');

                        const totalPoints = data.rankPoints || 0;
                        let rank = "BRONZE";
                        let rankImg = "bronze.png";
                        let nextRankPoints = 500;

                        if (totalPoints >= 2000) {
                            rank = "HEROIC";
                            rankImg = "heroic.png";
                            nextRankPoints = "MAX";
                        } else if (totalPoints >= 1500) {
                            rank = "DIAMOND";
                            rankImg = "diamond.png";
                            nextRankPoints = 2000;
                        } else if (totalPoints >= 1000) {
                            rank = "GOLD";
                            rankImg = "gold.png";
                            nextRankPoints = 1500;
                        } else if (totalPoints >= 500) {
                            rank = "SILVER";
                            rankImg = "silver.png";
                            nextRankPoints = 1000;
                        } else {
                            rank = "BRONZE";
                            rankImg = "bronze.png";
                            nextRankPoints = 500;
                        }

                        if (elRankTitle) elRankTitle.innerText = rank;
                        if (elRankIcon) elRankIcon.innerHTML = `<img src="ranks/${rankImg}" alt="${rank}" style="width: 100%; height: 100%; object-fit: contain;">`;
                        if (elRankPoints) elRankPoints.innerText = `RANK POINTS: ${totalPoints} / ${nextRankPoints}`;

                        // --- HONOR SCORE DYNAMIC ---
                        const honor = data.honorScore !== undefined ? data.honorScore : 100;
                        const elHonorValue = document.getElementById('profHonorValue');
                        const elHonorBar = document.getElementById('profHonorBar');
                        const elHonorStatus = document.getElementById('profHonorStatus');

                        if (elHonorValue) elHonorValue.innerText = `${honor}/100`;
                        if (elHonorBar) elHonorBar.style.width = `${honor}%`;

                        if (elHonorStatus) {
                            if (honor >= 90) { elHonorStatus.innerText = "EXCELLENT"; elHonorStatus.style.color = "#0f6"; }
                            else if (honor >= 70) { elHonorStatus.innerText = "STABLE"; elHonorStatus.style.color = "#ff0"; }
                            else { elHonorStatus.innerText = "SUSPICIOUS"; elHonorStatus.style.color = "#f44"; }
                        }
                    }
                } catch (e) {
                    console.error("Profile Stats Fetch Error:", e);
                }
            }
        }

        async function handleVictory() {
            if (!db || !myKey) return;
            window.raceOver = true;

            // Clear penalty flag
            updateDoc(doc(db, "all_users", myKey), { lastRaceActive: false }).catch(e => console.log(e));

            // 1. Show UI
            iziToast.show({
                theme: 'dark',
                icon: 'ðŸ†',
                title: 'VICTORY',
                message: 'You reached the finish line!',
                position: 'bottomRight',
                backgroundColor: 'rgba(0, 212, 255, 0.9)',
                progressBarColor: '#ff3e7f',
                timeout: 8000,
                close: true,
                class: 'victory-toast' // Custom class for positioning
            });

            const backBtn = document.getElementById('backToLobbyBtn');
            if (backBtn) {
                backBtn.style.display = 'block';
                gsap.from(backBtn, { x: 100, opacity: 0, duration: 0.5, ease: "back.out(1.7)" });
            }

            // Start Finish Sequence
            startRaceFinishSequence();

            // 2. Broadcast to others via Socket
            if (window.socket) {
                window.socket.emit('winner', { id: myKey, name: myUsername });
            }

            // 3. Update Stats in Firestore
            try {
                await updateDoc(doc(db, "all_users", myKey), {
                    wins: increment(1),
                    rankPoints: increment(250),
                    honorScore: increment(2),
                    coins: increment(100)
                });

                // Cap honor at 100
                const snap = await getDoc(doc(db, "all_users", myKey));
                if (snap.exists() && snap.data().honorScore > 100) {
                    await updateDoc(doc(db, "all_users", myKey), { honorScore: 100 });
                }

                await addDoc(collection(db, "match_history"), {
                    userId: myKey,
                    timestamp: serverTimestamp(),
                    result: 'WIN',
                    coins: 100
                });
            } catch (e) {
                console.error("Victory Stats Error:", e);
            }
        }

        if (window.socket) {
            window.socket.on('show_winner', (data) => {
                // Ensure data is an object with name
                const winnerName = (typeof data === 'string') ? 'Someone' : data.name;
                const winnerId = (typeof data === 'string') ? data : data.id;

                if (winnerId !== myKey && !window.raceOver) {
                    window.raceOver = true;

                    // Clear penalty flag for non-winners too
                    updateDoc(doc(db, "all_users", myKey), { lastRaceActive: false }).catch(e => console.log(e));

                    iziToast.info({
                        title: 'RACE OVER',
                        message: `${winnerName} has won the race!`,
                        position: 'bottomRight',
                        backgroundColor: 'rgba(255, 62, 127, 0.9)',
                        timeout: 8000
                    });

                    const backBtn = document.getElementById('backToLobbyBtn');
                    if (backBtn) {
                        backBtn.style.display = 'block';
                        gsap.from(backBtn, { x: 100, opacity: 0, duration: 0.5, ease: "back.out(1.7)" });
                    }

                    // Add loss to history
                    addDoc(collection(db, "match_history"), {
                        userId: myKey,
                        timestamp: serverTimestamp(),
                        result: 'LOSS',
                        coins: 20
                    });

                    // Award small points for finishing even if loss
                    updateDoc(doc(db, "all_users", myKey), {
                        rankPoints: increment(50),
                        honorScore: increment(2),
                        coins: increment(20)
                    }).then(async () => {
                        // Cap honor at 100
                        const snap = await getDoc(doc(db, "all_users", myKey));
                        if (snap.exists() && snap.data().honorScore > 100) {
                            await updateDoc(doc(db, "all_users", myKey), { honorScore: 100 });
                        }
                    }).catch(e => console.error(e));

                    // Start Finish Sequence for losers too
                    startRaceFinishSequence();
                }
            });
        }

        async function startRaceFinishSequence() {
            const countdownEl = document.getElementById('raceFinishCountdown');
            const countdownValue = document.getElementById('countdownValue');
            const lobbyLoader = document.getElementById('lobbyLoader');
            const lobbyLoadingText = document.getElementById('lobbyLoadingText');
            const backBtn = document.getElementById('backToLobbyBtn');

            if (!countdownEl || !countdownValue) return;

            const triggerLobbyLoad = () => {
                if (window.lobbyLoadingStarted) return;
                window.lobbyLoadingStarted = true;

                clearInterval(timer);
                if (countdownEl) countdownEl.style.display = 'none';
                if (backBtn) backBtn.style.display = 'none';

                // Show Lobby Loader
                if (lobbyLoader) {
                    lobbyLoader.style.display = 'flex';
                    let progress = 0;
                    const loadTimer = setInterval(() => {
                        progress += Math.floor(Math.random() * 15) + 5;
                        if (progress >= 100) {
                            progress = 100;
                            clearInterval(loadTimer);
                            setTimeout(() => location.reload(), 500);
                        }
                        if (lobbyLoadingText) {
                            lobbyLoadingText.innerText = `Preparing Lobby... ${progress}%`;
                        }
                    }, 150);
                } else {
                    location.reload();
                }
            };

            if (backBtn) {
                backBtn.onclick = triggerLobbyLoad;
            }

            countdownEl.style.display = 'flex';
            let timeLeft = 10;
            countdownValue.innerText = timeLeft;

            const timer = setInterval(() => {
                timeLeft--;
                countdownValue.innerText = timeLeft;

                // Pulsate effect
                gsap.fromTo(countdownValue, { scale: 1.2, opacity: 0.8 }, { scale: 1, opacity: 1, duration: 0.3 });

                if (timeLeft <= 0) {
                    clearInterval(timer);
                    countdownEl.style.display = 'none';

                    // Show Lobby Loader
                    if (lobbyLoader) {
                        lobbyLoader.style.display = 'flex';
                        let progress = 0;
                        const loadTimer = setInterval(() => {
                            progress += Math.floor(Math.random() * 15) + 5;
                            if (progress >= 100) {
                                progress = 100;
                                clearInterval(loadTimer);
                                setTimeout(() => location.reload(), 500);
                            }
                            if (lobbyLoadingText) {
                                lobbyLoadingText.innerText = `Preparing Lobby... ${progress}%`;
                            }
                        }, 150);
                    } else {
                        location.reload();
                    }
                }
            }, 1000);
        }

        setTimeout(() => { updateSquadPanel(); updateStartButtonState(); updateReadyButtonUI(); }, 2000);

        // ========== MARKETPLACE (SHOP) SYSTEM ==========
        let shopScene, shopCamera, shopRenderer, shopMixer, shopModel;
        let isShopOpen = false;
        let currentShopTab = 'characters';
        let userCoins = 0;
        let ownedItems = [];

        const shopItems = {
            characters: [
                { id: 'char1', name: 'RED RACER', price: 0, model: 'assets/character1.glb', icon: 'ðŸƒ' },
                { id: 'char2', name: 'BLUE BLITZ', price: 500, model: 'assets/character2.glb', icon: 'âš¡' },
                { id: 'char3', name: 'GREEN FLASH', price: 1000, model: 'assets/character3.glb', icon: 'ðŸŸ¢' },
                { id: 'char4', name: 'WHITE STRIKE', price: 2000, model: 'assets/character4.glb', icon: 'âš”ï¸' },
                { id: 'char5', name: 'PINK FURY', price: 5000, model: 'assets/character5.glb', icon: 'ðŸ”¥' },
                { id: 'char6', name: 'YELLOW BOLT', price: 10000, model: 'assets/character6.glb', icon: 'â­' }
            ],
            outfits: [
                { id: 'outfit1', name: 'ELITE VEST', price: 300, icon: 'ðŸ‘•' },
                { id: 'outfit2', name: 'NEON PANTS', price: 400, icon: 'ðŸ‘–' },
                { id: 'outfit3', name: 'SPEED BOOTS', price: 600, icon: 'ðŸ‘Ÿ' },
                { id: 'outfit4', name: 'CYBER HELMET', price: 1200, icon: 'ðŸª–' },
                { id: 'outfit5', name: 'GOLDEN CAPE', price: 2500, icon: 'ðŸ§£' }
            ],
            accessories: [
                { id: 'acc1', name: 'GLOW AURA', price: 1500, icon: 'âœ¨' },
                { id: 'acc2', name: 'SPEED TRAIL', price: 3000, icon: 'ðŸ’¨' }
            ]
        };

        function initShop3D() {
            const canvas = document.getElementById('shopCharCanvas');
            if (!canvas) return;

            shopRenderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            shopRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
            shopRenderer.setPixelRatio(window.devicePixelRatio);

            shopScene = new THREE.Scene();
            shopCamera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
            shopCamera.position.set(0, 1, 4.5);
            shopCamera.lookAt(0, 0, 0);

            const ambient = new THREE.AmbientLight(0xffffff, 1.5);
            shopScene.add(ambient);

            const spot = new THREE.SpotLight(0xffffff, 1.5);
            spot.position.set(5, 10, 5);
            shopScene.add(spot);

            loadShopModel(selectedModelPath);
        }

        function loadShopModel(path) {
            if (!path) return;
            const loader = new GLTFLoader();

            // For preview, use the character model ideally
            loader.load(path, (gltf) => {
                if (shopModel) shopScene.remove(shopModel);
                shopModel = gltf.scene;
                shopModel.position.y = -1.5;
                shopModel.scale.set(1.8, 1.8, 1.8);
                shopScene.add(shopModel);

                shopMixer = new THREE.AnimationMixer(shopModel);
                const anim = gltf.animations.find(a => a.name.toLowerCase().includes('idle')) || gltf.animations[0];
                if (anim) shopMixer.clipAction(anim).play();
            });
        }

        function animateShop() {
            if (!isShopOpen) return;
            requestAnimationFrame(animateShop);
            if (shopMixer) shopMixer.update(0.016);
            if (shopModel) shopModel.rotation.y += 0.01;
            shopRenderer.render(shopScene, shopCamera);
        }

        function populateShop(category) {
            const grid = document.getElementById('shopItemGrid');
            if (!grid) return;
            grid.innerHTML = '';

            const items = shopItems[category];
            items.forEach(item => {
                const isOwned = ownedItems.includes(item.id) || item.price === 0;
                const isEquipped = selectedModelPath === item.model;

                const div = document.createElement('div');
                div.className = `shop-item ${isEquipped ? 'equipped' : ''}`;
                div.innerHTML = `
                    <div class="item-icon">${item.icon}</div>
                    <div class="item-name">${item.name}</div>
                    ${!isOwned ? `
                        <div class="item-price">ðŸ’° ${item.price}</div>
                        <button class="btn-buy" onclick="buyItem('${category}', '${item.id}')">BUY</button>
                    ` : `
                        <button class="btn-buy btn-equip" onclick="equipItem('${category}', '${item.id}')">${isEquipped ? 'EQUIPPED' : 'EQUIP'}</button>
                    `}
                `;

                // Clicking the item previews it
                div.onclick = (e) => {
                    if (e.target.tagName !== 'BUTTON') {
                        if (item.model) loadShopModel(item.model);
                    }
                };

                grid.appendChild(div);
            });
        }

        window.buyItem = async (category, itemId) => {
            const item = shopItems[category].find(i => i.id === itemId);
            if (!item) return;

            if (userCoins < item.price) {
                iziToast.error({ title: 'POOR', message: 'Not enough coins!', position: 'topCenter' });
                return;
            }

            try {
                // Deduct coins and add to ownedItems
                await updateDoc(doc(db, "all_users", myKey), {
                    coins: increment(-item.price),
                    ownedItems: [...ownedItems, itemId]
                });

                iziToast.success({ title: 'PURCHASED', message: `${item.name} unlocked!`, position: 'topCenter' });
                // ownedItems will be updated by the listener
            } catch (e) {
                console.error("Purchase error:", e);
                iziToast.error({ message: "Purchase failed!" });
            }
        };

        window.equipItem = async (category, itemId) => {
            const item = shopItems[category].find(i => i.id === itemId);
            if (!item || !item.model) {
                iziToast.info({ message: "Equipped! (Visual only for now)" });
                return;
            }

            try {
                selectedModelPath = item.model;
                localStorage.setItem('runArena_model', selectedModelPath);

                await updateDoc(doc(db, "players", myKey), { model: selectedModelPath });

                iziToast.success({ title: 'EQUIPPED', message: `${item.name} is ready!`, position: 'topCenter' });
                populateShop(category);

                // Reload Lobby model
                if (window.location.reload) {
                    iziToast.info({ message: "Reloading to apply changes...", timeout: 2000 });
                    setTimeout(() => location.reload(), 1500);
                }
            } catch (e) {
                console.error("Equip error:", e);
            }
        };

        // Tab Switching
        document.querySelectorAll('.shop-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.shop-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentShopTab = tab.dataset.tab;
                populateShop(currentShopTab);
            });
        });

        // Open/Close
        const walletBtn = document.getElementById('walletBtn');
        if (walletBtn) {
            walletBtn.addEventListener('click', () => {
                isShopOpen = true;
                const modal = document.getElementById('shopModal');
                if (modal) modal.classList.add('active');

                // Small delay to ensure display: flex is applied before 3D init
                setTimeout(() => {
                    if (!shopRenderer) initShop3D();
                    else loadShopModel(selectedModelPath);

                    animateShop();
                    populateShop(currentShopTab);
                    updateShopUI();
                }, 50);
            });
        }

        document.getElementById('closeShopBtn').addEventListener('click', () => {
            isShopOpen = false;
            document.getElementById('shopModal').classList.remove('active');
        });

        function updateShopUI() {
            document.getElementById('shopBalanceValue').innerText = userCoins;
            document.getElementById('coinBalanceTop').innerText = userCoins;
        }

        // Firestore Listener for Coins & Owned Items
        function startShopSync() {
            if (!db || !myKey) return;
            onSnapshot(doc(db, "all_users", myKey), (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    userCoins = data.coins || 0;
                    ownedItems = data.ownedItems || ['char1'];
                    updateShopUI();
                    if (isShopOpen) populateShop(currentShopTab);
                }
            });
        }

        // Initialize sync after a short delay to ensure myKey is set
        setTimeout(startShopSync, 3000);
    </script>
</body>

</html>